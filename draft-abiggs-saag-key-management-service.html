<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Key Management Service Architecture</title>

  <style type="text/css" title="Xml2Rfc (sans serif)">
  /*<![CDATA[*/
	  a {
	  text-decoration: none;
	  }
      /* info code from SantaKlauss at http://www.madaboutstyle.com/tooltip2.html */
      a.info {
          /* This is the key. */
          position: relative;
          z-index: 24;
          text-decoration: none;
      }
      a.info:hover {
          z-index: 25;
          color: #FFF; background-color: #900;
      }
      a.info span { display: none; }
      a.info:hover span.info {
          /* The span will display just on :hover state. */
          display: block;
          position: absolute;
          font-size: smaller;
          top: 2em; left: -5em; width: 15em;
          padding: 2px; border: 1px solid #333;
          color: #900; background-color: #EEE;
          text-align: left;
      }
	  a.smpl {
	  color: black;
	  }
	  a:hover {
	  text-decoration: underline;
	  }
	  a:active {
	  text-decoration: underline;
	  }
	  address {
	  margin-top: 1em;
	  margin-left: 2em;
	  font-style: normal;
	  }
	  body {
	  color: black;
	  font-family: verdana, helvetica, arial, sans-serif;
	  font-size: 10pt;
	  max-width: 55em;
	  
	  }
	  cite {
	  font-style: normal;
	  }
	  dd {
	  margin-right: 2em;
	  }
	  dl {
	  margin-left: 2em;
	  }
	
	  ul.empty {
	  list-style-type: none;
	  }
	  ul.empty li {
	  margin-top: .5em;
	  }
	  dl p {
	  margin-left: 0em;
	  }
	  dt {
	  margin-top: .5em;
	  }
	  h1 {
	  font-size: 14pt;
	  line-height: 21pt;
	  page-break-after: avoid;
	  }
	  h1.np {
	  page-break-before: always;
	  }
	  h1 a {
	  color: #333333;
	  }
	  h2 {
	  font-size: 12pt;
	  line-height: 15pt;
	  page-break-after: avoid;
	  }
	  h3, h4, h5, h6 {
	  font-size: 10pt;
	  page-break-after: avoid;
	  }
	  h2 a, h3 a, h4 a, h5 a, h6 a {
	  color: black;
	  }
	  img {
	  margin-left: 3em;
	  }
	  li {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  ol p {
	  margin-left: 0em;
	  }
	  p {
	  margin-left: 2em;
	  margin-right: 2em;
	  }
	  pre {
	  margin-left: 3em;
	  background-color: lightyellow;
	  padding: .25em;
	  }
	  pre.text2 {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f0f0f0;
	  width: 69em;
	  }
	  pre.inline {
	  background-color: white;
	  padding: 0em;
	  }
	  pre.text {
	  border-style: dotted;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  width: 69em;
	  }
	  pre.drawing {
	  border-style: solid;
	  border-width: 1px;
	  background-color: #f8f8f8;
	  padding: 2em;
	  }
	  table {
	  margin-left: 2em;
	  }
	  table.tt {
	  vertical-align: top;
	  }
	  table.full {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.headers {
	  border-style: outset;
	  border-width: 1px;
	  }
	  table.tt td {
	  vertical-align: top;
	  }
	  table.full td {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.tt th {
	  vertical-align: top;
	  }
	  table.full th {
	  border-style: inset;
	  border-width: 1px;
	  }
	  table.headers th {
	  border-style: none none inset none;
	  border-width: 1px;
	  }
	  table.left {
	  margin-right: auto;
	  }
	  table.right {
	  margin-left: auto;
	  }
	  table.center {
	  margin-left: auto;
	  margin-right: auto;
	  }
	  caption {
	  caption-side: bottom;
	  font-weight: bold;
	  font-size: 9pt;
	  margin-top: .5em;
	  }
	
	  table.header {
	  border-spacing: 1px;
	  width: 95%;
	  font-size: 10pt;
	  color: white;
	  }
	  td.top {
	  vertical-align: top;
	  }
	  td.topnowrap {
	  vertical-align: top;
	  white-space: nowrap; 
	  }
	  table.header td {
	  background-color: gray;
	  width: 50%;
	  }
	  table.header a {
	  color: white;
	  }
	  td.reference {
	  vertical-align: top;
	  white-space: nowrap;
	  padding-right: 1em;
	  }
	  thead {
	  display:table-header-group;
	  }
	  ul.toc, ul.toc ul {
	  list-style: none;
	  margin-left: 1.5em;
	  margin-right: 0em;
	  padding-left: 0em;
	  }
	  ul.toc li {
	  line-height: 150%;
	  font-weight: bold;
	  font-size: 10pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  ul.toc li li {
	  line-height: normal;
	  font-weight: normal;
	  font-size: 9pt;
	  margin-left: 0em;
	  margin-right: 0em;
	  }
	  li.excluded {
	  font-size: 0pt;
	  }
	  ul p {
	  margin-left: 0em;
	  }
	
	  .comment {
	  background-color: yellow;
	  }
	  .center {
	  text-align: center;
	  }
	  .error {
	  color: red;
	  font-style: italic;
	  font-weight: bold;
	  }
	  .figure {
	  font-weight: bold;
	  text-align: center;
	  font-size: 9pt;
	  }
	  .filename {
	  color: #333333;
	  font-weight: bold;
	  font-size: 12pt;
	  line-height: 21pt;
	  text-align: center;
	  }
	  .fn {
	  font-weight: bold;
	  }
	  .hidden {
	  display: none;
	  }
	  .left {
	  text-align: left;
	  }
	  .right {
	  text-align: right;
	  }
	  .title {
	  color: #990000;
	  font-size: 18pt;
	  line-height: 18pt;
	  font-weight: bold;
	  text-align: center;
	  margin-top: 36pt;
	  }
	  .vcardline {
	  display: block;
	  }
	  .warning {
	  font-size: 14pt;
	  background-color: yellow;
	  }
	
	
	  @media print {
	  .noprint {
		display: none;
	  }
	
	  a {
		color: black;
		text-decoration: none;
	  }
	
	  table.header {
		width: 90%;
	  }
	
	  td.header {
		width: 50%;
		color: black;
		background-color: white;
		vertical-align: top;
		font-size: 12pt;
	  }
	
	  ul.toc a::after {
		content: leader('.') target-counter(attr(href), page);
	  }
	
	  ul.ind li li a {
		content: target-counter(attr(href), page);
	  }
	
	  .print2col {
		column-count: 2;
		-moz-column-count: 2;
		column-fill: auto;
	  }
	  }
	
	  @page {
	  @top-left {
		   content: "Internet-Draft"; 
	  } 
	  @top-right {
		   content: "December 2010"; 
	  } 
	  @top-center {
		   content: "Abbreviated Title";
	  } 
	  @bottom-left {
		   content: "Doe"; 
	  } 
	  @bottom-center {
		   content: "Expires June 2011"; 
	  } 
	  @bottom-right {
		   content: "[Page " counter(page) "]"; 
	  } 
	  }
	
	  @page:first { 
		@top-left {
		  content: normal;
		}
		@top-right {
		  content: normal;
		}
		@top-center {
		  content: normal;
		}
	  }
  /*]]>*/
  </style>

  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology">
<link href="#rfc.section.1.2" rel="Chapter" title="1.2 Security Terms">
<link href="#rfc.section.1.3" rel="Chapter" title="1.3 Notational Conventions">
<link href="#rfc.section.2" rel="Chapter" title="2 Architectural Overview">
<link href="#rfc.section.3" rel="Chapter" title="3 Use Cases">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Securing an HTTP File Sharing Service">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Securing an XMPP Multi-User Chat">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 KMS to KMS Key Federation">
<link href="#rfc.section.4" rel="Chapter" title="4 KMS Protocol">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 Secure Channel">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 User Identity">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 KMS Identity">
<link href="#rfc.section.4.4" rel="Chapter" title="4.4 Object Types">
<link href="#rfc.section.4.4.1" rel="Chapter" title="4.4.1 KMS Key Objects">
<link href="#rfc.section.4.4.2" rel="Chapter" title="4.4.2 KMS Authorization Objects">
<link href="#rfc.section.4.4.3" rel="Chapter" title="4.4.3 KMS Resource Objects (KRO)">
<link href="#rfc.section.4.5" rel="Chapter" title="4.5 Request Types">
<link href="#rfc.section.4.6" rel="Chapter" title="4.6 Message Structure">
<link href="#rfc.section.4.6.1" rel="Chapter" title="4.6.1 Basic Request Payload">
<link href="#rfc.section.4.6.2" rel="Chapter" title="4.6.2 Basic Response Payload">
<link href="#rfc.section.4.6.3" rel="Chapter" title="4.6.3 Error Response Payload">
<link href="#rfc.section.4.7" rel="Chapter" title="4.7 Requests">
<link href="#rfc.section.4.7.1" rel="Chapter" title="4.7.1 Create Ephemeral Key">
<link href="#rfc.section.4.7.2" rel="Chapter" title="4.7.2 Delete Ephemeral Key">
<link href="#rfc.section.4.7.3" rel="Chapter" title="4.7.3 Create Resource">
<link href="#rfc.section.4.7.4" rel="Chapter" title="4.7.4 Retrieve Resource">
<link href="#rfc.section.4.7.5" rel="Chapter" title="4.7.5 Create Keys">
<link href="#rfc.section.4.7.6" rel="Chapter" title="4.7.6 Update Key (Bind)">
<link href="#rfc.section.4.7.7" rel="Chapter" title="4.7.7 Retrieve Keys">
<link href="#rfc.section.4.7.8" rel="Chapter" title="4.7.8 Create Authorizations">
<link href="#rfc.section.4.7.9" rel="Chapter" title="4.7.9 Retrieve Authorizations">
<link href="#rfc.section.4.7.10" rel="Chapter" title="4.7.10 Retrieve Authorizations By User">
<link href="#rfc.section.4.7.11" rel="Chapter" title="4.7.11 Delete Authorization">
<link href="#rfc.section.4.7.12" rel="Chapter" title="4.7.12 Ping">
<link href="#rfc.section.5" rel="Chapter" title="5 Mandatory-to-Implement">
<link href="#rfc.section.6" rel="Chapter" title="6 Security Considerations">
<link href="#rfc.section.7" rel="Chapter" title="7 Appendix A. Acknowledgments">
<link href="#rfc.section.8" rel="Chapter" title="8 Appendix B. Document History">
<link href="#rfc.references" rel="Chapter" title="9 References">
<link href="#rfc.references.1" rel="Chapter" title="9.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="9.2 Informative References">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.15.4 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Biggs, A. and S. Cooley" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-abiggs-saag-key-management-service-02" />
  <meta name="dct.issued" scheme="ISO8601" content="2018-08-01" />
  <meta name="dct.abstract" content="In the interest of addressing pervasive threats to the confidentiality and integrity of online communications identified by the Internet community  this specification introduces an open architecture for the establishment, management, and secure distribution of cryptographic keys for use in the end-to-end (E2E) encryption of online communications and shared content.  This architecture allows for the independent deployment of dedicated key management services in a manner that supports the adoption of third-party communications and data sharing services by individuals and organizations that require full and exclusive discretion over the confidentiality of their data." />
  <meta name="description" content="In the interest of addressing pervasive threats to the confidentiality and integrity of online communications identified by the Internet community  this specification introduces an open architecture for the establishment, management, and secure distribution of cryptographic keys for use in the end-to-end (E2E) encryption of online communications and shared content.  This architecture allows for the independent deployment of dedicated key management services in a manner that supports the adoption of third-party communications and data sharing services by individuals and organizations that require full and exclusive discretion over the confidentiality of their data." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">Network Working Group</td>
<td class="right">A. Biggs</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">S. Cooley</td>
</tr>
<tr>
<td class="left">Intended status: Informational</td>
<td class="right">Cisco Systems</td>
</tr>
<tr>
<td class="left">Expires: February 2, 2019</td>
<td class="right">August 01, 2018</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Key Management Service Architecture<br />
  <span class="filename">draft-abiggs-saag-key-management-service-02</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>In the interest of addressing pervasive threats to the confidentiality and integrity of online communications identified by the Internet community <a href="#I-D.barnes-pervasive-problem" class="xref">[I-D.barnes-pervasive-problem]</a> this specification introduces an open architecture for the establishment, management, and secure distribution of cryptographic keys for use in the end-to-end (E2E) encryption of online communications and shared content.  This architecture allows for the independent deployment of dedicated key management services in a manner that supports the adoption of third-party communications and data sharing services by individuals and organizations that require full and exclusive discretion over the confidentiality of their data.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on February 2, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2018 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a>
</li>
<li>1.2.   <a href="#rfc.section.1.2">Security Terms</a>
</li>
<li>1.3.   <a href="#rfc.section.1.3">Notational Conventions</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">Architectural Overview</a>
</li>
<li>3.   <a href="#rfc.section.3">Use Cases</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Securing an HTTP File Sharing Service</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Securing an XMPP Multi-User Chat</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">KMS to KMS Key Federation</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">KMS Protocol</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">Secure Channel</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">User Identity</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">KMS Identity</a>
</li>
<li>4.4.   <a href="#rfc.section.4.4">Object Types</a>
</li>
<ul><li>4.4.1.   <a href="#rfc.section.4.4.1">KMS Key Objects</a>
</li>
<li>4.4.2.   <a href="#rfc.section.4.4.2">KMS Authorization Objects</a>
</li>
<li>4.4.3.   <a href="#rfc.section.4.4.3">KMS Resource Objects (KRO)</a>
</li>
</ul><li>4.5.   <a href="#rfc.section.4.5">Request Types</a>
</li>
<li>4.6.   <a href="#rfc.section.4.6">Message Structure</a>
</li>
<ul><li>4.6.1.   <a href="#rfc.section.4.6.1">Basic Request Payload</a>
</li>
<li>4.6.2.   <a href="#rfc.section.4.6.2">Basic Response Payload</a>
</li>
<li>4.6.3.   <a href="#rfc.section.4.6.3">Error Response Payload</a>
</li>
</ul><li>4.7.   <a href="#rfc.section.4.7">Requests</a>
</li>
<ul><li>4.7.1.   <a href="#rfc.section.4.7.1">Create Ephemeral Key</a>
</li>
<li>4.7.2.   <a href="#rfc.section.4.7.2">Delete Ephemeral Key</a>
</li>
<li>4.7.3.   <a href="#rfc.section.4.7.3">Create Resource</a>
</li>
<li>4.7.4.   <a href="#rfc.section.4.7.4">Retrieve Resource</a>
</li>
<li>4.7.5.   <a href="#rfc.section.4.7.5">Create Keys</a>
</li>
<li>4.7.6.   <a href="#rfc.section.4.7.6">Update Key (Bind)</a>
</li>
<li>4.7.7.   <a href="#rfc.section.4.7.7">Retrieve Keys</a>
</li>
<li>4.7.8.   <a href="#rfc.section.4.7.8">Create Authorizations</a>
</li>
<li>4.7.9.   <a href="#rfc.section.4.7.9">Retrieve Authorizations</a>
</li>
<li>4.7.10.   <a href="#rfc.section.4.7.10">Retrieve Authorizations By User</a>
</li>
<li>4.7.11.   <a href="#rfc.section.4.7.11">Delete Authorization</a>
</li>
<li>4.7.12.   <a href="#rfc.section.4.7.12">Ping</a>
</li>
</ul></ul><li>5.   <a href="#rfc.section.5">Mandatory-to-Implement</a>
</li>
<li>6.   <a href="#rfc.section.6">Security Considerations</a>
</li>
<li>7.   <a href="#rfc.section.7">Appendix A. Acknowledgments</a>
</li>
<li>8.   <a href="#rfc.section.8">Appendix B. Document History</a>
</li>
<li>9.   <a href="#rfc.references">References</a>
</li>
<ul><li>9.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>9.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#introduction" id="introduction">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">Providers of cloud-based services commonly secure user data at the transport level using established protocols such as TLS <a href="#RFC5246" class="xref">[RFC5246]</a> or IPSec <a href="#RFC4301" class="xref">[RFC4301]</a>.  These protocols can be effective in protecting transmitted user data from third party tampering and eavesdropping; however, by themselves these protocols do not secure user data from abuses, negligence, or coerced behavior on the part of the cloud provider.  This is a concern for individuals and organizations that wish to take advantage of cloud-based communications and collaboration but cannot accept the risk of trusting cloud providers with unfettered access to the contents of their communications.</p>
<p id="rfc.section.1.p.2">E2E encryption describes a category of solutions that can be employed to address this problem by establishing secure channels among clients.  To the extent that a user can trust their collaboration client software, E2E encryption mitigates exposure of user data to untrusted parties by ensuring that intermediaries never possess unencrypted user data or have access to the keying material necessary to decrypt it.</p>
<p id="rfc.section.1.p.3">Existing E2E strategies such as ECS <a href="#RFC5652" class="xref">[RFC5652]</a>, PGP <a href="#RFC4880" class="xref">[RFC4880]</a>, and Off-the-Record Messaging <a href="#OTR" class="xref">[OTR]</a> can be effective at securing two-party communications. However, E2E encryption for the growing domain of multiparty communications and online content sharing remains a generally unsolved problem to which these existing approaches do not readily adapt.  In particular, a core challenge exists in providing for the secure distribution and rotation of E2E encryption keys among an arbitrary and potentially dynamic set of communicating clients.  In cases where the communications to be secured are persistent or archived, the additional challenge exists for providing trusted long-term storage and retrieval of these keys.</p>
<p id="rfc.section.1.p.4">Equally problematic is the paucity of E2E encryption options that satisfy common organizational obligations such as regulatory compliance and legal discovery.  Entities that must operate within such frameworks require mechanisms by which they (and they alone) may recover the keys used to secure their communications.  Existing E2E encryption solutions are not, by themselves, well suited for this purpose.</p>
<p id="rfc.section.1.p.5">In the interest of addressing these challenges this document presents an architecture for the deployment of E2E encryption key management services (KMS).  In this architecture, a KMS provides to its users a means by which their communications clients may securely create, share, rotate, and store E2E encryption keying material.  It does so in a fashion that permits the decoupling of such services from the communications media, thereby permitting the former to reside under the direct control of the communicating parties or the organizations within which they do business.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.1.p.1">This document uses the terminology from <a href="#I-D.ietf-jose-json-web-signature" class="xref">[I-D.ietf-jose-json-web-signature]</a>, <a href="#I-D.ietf-jose-json-web-encryption" class="xref">[I-D.ietf-jose-json-web-encryption]</a>, <a href="#I-D.ietf-jose-json-web-key" class="xref">[I-D.ietf-jose-json-web-key]</a>, and <a href="#I-D.ietf-jose-json-web-algorithms" class="xref">[I-D.ietf-jose-json-web-algorithms]</a> when discussing JOSE technologies.</p>
<p id="rfc.section.1.1.p.2">This document makes use of the following terminology, and additionally adopts nomenclature defined in <a href="#I-D.barnes-pervasive-problem" class="xref">[I-D.barnes-pervasive-problem]</a> for the purpose of describing aspects of pervasive attacks.</p>
<p id="rfc.section.1.1.p.3">communications resource</p>
<p></p>

<ul class="empty"><li>A communications resource is any uniquely identifiable continuous data channel or discrete shared content that represents an exchange of personal communications between two or more users.</li></ul>
<p id="rfc.section.1.1.p.5">communications resource client</p>
<p></p>

<ul class="empty"><li>A communications resource client consumes communications resources on behalf of a user and, when deployed in conformance with the KMS architecture, consumes the services of KMS server(s) to facilitate the E2E encryption of those communications resources.</li></ul>
<p id="rfc.section.1.1.p.7">communications resource server</p>
<p></p>

<ul class="empty"><li>A communications resource server is a provider of services through which communications resources are made available.</li></ul>
<p id="rfc.section.1.1.p.9">cloud provider</p>
<p></p>

<ul class="empty"><li>An individual or organization responsible for, and in control of, one or more communications resource servers.</li></ul>
<p id="rfc.section.1.1.p.11">E2E encryption</p>
<p></p>

<ul class="empty"><li>Shorthand for end-to-end encryption, as defined in <a href="#RFC4949" class="xref">[RFC4949]</a>, particularly as it applies to the establishment of confidentiality and integrity of communications resources.</li></ul>
<p id="rfc.section.1.1.p.13">KMS server</p>
<p></p>

<ul class="empty"><li>A key management service (KMS) server is responsible for creating, storing, and providing access to E2E encryption keying material by communications resource clients.</li></ul>
<p id="rfc.section.1.1.p.15">KMS protocol</p>
<p></p>

<ul class="empty"><li>The protocol through which communications resource clients interoperate with KMS servers.</li></ul>
<p id="rfc.section.1.1.p.17">KMS provider</p>
<p></p>

<ul class="empty"><li>An individual or organization responsible for, and in control of, a KMS server deployment.</li></ul>
<p id="rfc.section.1.1.p.19">KMS transport</p>
<p></p>

<ul class="empty"><li>Any service or protocol that provides the basic transport over which KMS protocol messages are exchanged.</li></ul>
<p id="rfc.section.1.1.p.21">resource client</p>
<p></p>

<ul class="empty"><li>See communications resource client.</li></ul>
<p id="rfc.section.1.1.p.23">resource server</p>
<p></p>

<ul class="empty"><li>See communications resource server.</li></ul>
<p id="rfc.section.1.1.p.25">trusted party</p>
<p></p>

<ul class="empty"><li>A trusted party is an individual or organization that is trusted by one or more communicating users to maintain the confidentiality and integrity of their communications resources.</li></ul>
<h1 id="rfc.section.1.2">
<a href="#rfc.section.1.2">1.2.</a> <a href="#security-terms" id="security-terms">Security Terms</a>
</h1>
<p id="rfc.section.1.2.p.1">Most security-related terms in this document are to be understood in the sense defined in <a href="#RFC4949" class="xref">[RFC4949]</a>; such terms include, but are not limited to, &#8220;attack&#8221;, &#8220;authentication&#8221;, &#8220;authorization&#8221;, &#8220;certification authority&#8221;, &#8220;certification path&#8221;, &#8220;certificate&#8221;, &#8220;credential&#8221;, &#8220;identity&#8221;, &#8220;self-signed certificate&#8221;, &#8220;trust&#8221;, &#8220;trust anchor&#8221;, &#8220;trust chain&#8221;, &#8220;validate&#8221;, and &#8220;verify&#8221;.</p>
<h1 id="rfc.section.1.3">
<a href="#rfc.section.1.3">1.3.</a> <a href="#notational-conventions" id="notational-conventions">Notational Conventions</a>
</h1>
<p id="rfc.section.1.3.p.1">In this document, the key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; are to be interpreted as described in BCP 14, RFC 2119 <a href="#RFC2119" class="xref">[RFC2119]</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#architectural-overview" id="architectural-overview">Architectural Overview</a>
</h1>
<p id="rfc.section.2.p.1">The architectural reference model for this specification is illustrated in <a href="#reference-model" class="xref">Figure 1</a>.  Central to this model is the <em>communications resource server</em> which is presumed to be operated by a <em>cloud provider</em> for the purpose of offering some form of communications service.  The nature of this service is not prescribed by this specification and may take the form of any of a variety of communications or collaboration services including file sharing, messaging, and VoIP.  Consuming the services of the communications resource server are <em>communications resource clients</em> which may be supplied by the cloud provider or developed by third parties.</p>
<div id="rfc.figure.1"></div>
<div id="reference-model"></div>
<pre>
                         +-----------------+
                         | Communications  |
     +-------------------| Resource Server |-------------------+
     |                   | (Cloud Provider)|                   |
     |                   +-----------------+                   |
     |                                                         |
     |                                                         |
     |                   +-----------------+                   |
     |       +-----------|  KMS Transport  |-----------+       |
     |       |           +-----------------+           |       |
     |       |                    |                    |       |
     |       |   Untrusted        |                    |       | 
- - -|- - - -|- - - - - - - - - - | - - - - - - - - - -|- - - -|- - -
     |       |   Trusted          |                    |       |
     |       |                    |                    |       |
+-----------------+      +-----------------+      +-----------------+
| Communications  |      |    KMS Server   |      | Communications  |
| Resource Client |      |  (KMS Provider) |      | Resource Client |
+-----------------+      +-----------------+      +-----------------+
         |                                                 |
+-----------------+                               +-----------------+
|      Alice      |                               |       Bob       |
+-----------------+                               +-----------------+
</pre>
<p class="figure">Figure 1: KMS Architecture Reference Model</p>
<p id="rfc.section.2.p.2">In addition to the familiar elements described above, this model also includes a key management server, or <em>KMS</em>, operated by a <em>KMS provider</em>. The KMS server exposes an API through which clients may securely establish and share cryptographic keying material used for the E2E encryption of content that is transited through the cloud provider&#8217;s services.  This API is secured in such a way as to ensure these keys are visible to none but the KMS server itself and the clients authorized to consume the content they protect.  This highlights an important distinction between the KMS provider and the cloud provider: while the KMS provider is necessarily a <em>trusted party</em>, the cloud provider need not be.</p>
<p id="rfc.section.2.p.3">It is an explicit objective of this specification to promote an ecosystem of providers of KMS implementations and KMS services that are distinct and independent of the cloud providers over whose services users communicate.  To that end, this specification seeks to standardize a KMS protocol through which clients and KMS servers interoperate.  This protocol provides for the establishment of a confidential and authenticated channel between each client and KMS server, and defines an API of request and response messages to be exchanged over this secure channel for the purpose of creating, retrieving, and exchanging keys.</p>
<p id="rfc.section.2.p.4">While the KMS protocol constitutes a central focus of this specification, the means by which this protocol is transported is expressly out of scope.  This role may be readily addressed through either standards-based or proprietary protocols, and so we refer to this simply as the <em>KMS transport</em> for the remainder of this document.  Over this transport, the communication paths between clients and KMS server are encrypted using keys established through an authenticated ephemeral key agreement.  As such, the KMS transport provider need not be regarded as a trusted party, and in fact may be the cloud provider itself.</p>
<p id="rfc.section.2.p.5">An important non-goal of this specification is the standardization of any aspect of the cloud provider&#8217;s services or the means by which clients utilize shared keys for the E2E encryption of data transiting those services.  By avoiding the application of constraints on the communications services and protocols we enable the use of this specification in the context of existing service deployments, both standards-based and proprietary.  It is similarly a non-goal of this specification to enable federation of secure communications between vendors of different cloud services, as that is the realm of standardized application protocols.  The scope of this specification is intended to be narrowly focused on the task of separating E2E encryption key management from the communications services they secure, thereby facilitating the broadest possible adoption of secure communications though existing services.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#use-cases" id="use-cases">Use Cases</a>
</h1>
<p id="rfc.section.3.p.1">The use cases described in this section are non-normative examples meant to illustrate how the KMS architecture may be deployed to provide E2E encryption of different types of communications resources.  These use cases differ in detail, but generally follow a common logical sequence as given below.</p>
<p id="rfc.section.3.p.2">Note that all requests to the KMS server are via the KMS transport which, for clarity, has been omitted from the sequence diagrams included in this section.</p>
<div id="rfc.figure.2"></div>
<div id="nominal-usecase"></div>
<pre>
  Resource          Resource          Resource            KMS
  Client B          Client A           Server            Server
     |                 |                 |                 |
     |                 |                 |       (1)       |
     |                 |-----------------|----------------&gt;|
     |                 |       (2)       |                 |
     |                 |----------------&gt;|                 |
     |                 |                 |       (3)       |
     |                 |-----------------|----------------&gt;|
     |                 |       (4)       |                 |
     |-----------------|----------------&gt;|                 |
     |                 |                 |                 |
 (5) |                 |                 |                 |
     |                 |                 |       (6)       |
     |-----------------|-----------------|----------------&gt;|
     |                 |                 |                 |
 (7) |                 |                 |                 |
     |                 |                 |                 |

</pre>
<p class="figure">Figure 2: Nominal Use Case</p>
<p></p>

<ol>
<li>Client A requests the generation of a new unbound key from the KMS.</li>
<li>Client A encrypts a communications resource using the unbound KMS key and shares it via a resource server.</li>
<li>Client A requests the creation of a new KMS resource object (KRO) to represent the communications resource.  Client A also instructs the KMS to bind the KMS key used in step (2) to the new KRO and to authorize user B to retrieve keys bound to the KRO.</li>
<li>Client B accesses the communications resource shared by client A and receives the encrypted data.</li>
<li>Client B obtains, through some means not defined by this specification, the URL of the KMS key used to encrypt the communications resource.</li>
<li>Client B requests the KMS key from the KMS server.  The KMS server, recognizing user B as authorized on the KRO to which the key is bound, returns the KMS key.</li>
<li>Client B decrypts the communications resource using the KMS key.</li>
</ol>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#securing-an-http-file-sharing-service" id="securing-an-http-file-sharing-service">Securing an HTTP File Sharing Service</a>
</h1>
<p id="rfc.section.3.1.p.1">Let A be a user that wishes to share a file with users B and C through some HTTP based file sharing service.  In the context of the KMS architecture we may regard the file sharing provider&#8217;s HTTP API as the resource server and the users&#8217; HTTP clients as the resource clients.</p>
<p id="rfc.section.3.1.p.2">For this scenario we also assume that the file sharing service is trusted by user A with the role of providing a file sharing service but is not necessarily trusted to adequately protect the confidentiality of the file contents.  User A&#8217;s concerns may then be addressed through the introduction of an HTTP based KMS transport (not shown) and KMS server deployed by an entity that A regards as a trusted party.</p>
<div id="rfc.figure.3"></div>
<div id="fileshare-usecase"></div>
<pre>
     HTTP           HTTP           HTTP       HTTP File         KMS
   Client C       Client B       Client A    Share Server      Server
      |              |              |              |             |
      |              |              |              |     (1)     |
      |              |              |--------------|------------&gt;|
      |              |              |      (2)     |             |
      |              |              |-------------&gt;|             |
      |      (3)     |      (3)     |              |             |
      |&lt;-------------|&lt;-------------|--------------|             |
      |              |              |              |     (4)     |
      |              |              |--------------|------------&gt;|
      |              |              |      (5)     |             |
      |              |--------------|-------------&gt;|             |
      |              |              |              |     (6)     |
      |              |--------------|--------------|------------&gt;|
      |              |              |              |             |
      |          (7) |              |              |             |
      |              |              |              |             |
  (8) |              |              |              |             |
      |              |              |              |             |
</pre>
<p class="figure">Figure 3: File Sharing Use Case</p>
<p id="rfc.section.3.1.p.3">This sequence begins with the assumption that each client has, at some point, already established a secure channel to the KMS via authenticated key agreement.</p>
<p></p>

<ol>
<li>Client A requests from the KMS some number of unbound KMS keys.</li>
<li>Client A selects an unbound key from the set of keys obtained step (1), encrypts the file to be shared, and posts the encrypted content to the file sharing service.  The file sharing service responds with a URL that uniquely identifies the shared file.</li>
<li>Clients B and C learn of the newly shared file from the file sharing service (the mechanism by which this occurs is out of scope for this specification).</li>
<li>Client A requests the creation of a KMS resource object (KRO) on the KMS to represent the shared file.  In this message the client also requests that the key from step (2) be bound to the newly created KRO and that the users of clients B and C be authorized to retrieve keys bound to the KRO.</li>
<li>Client B retrieves the shared file from the file sharing service.</li>
<li>Client B requests from the KMS all keys bound to the KRO associated with the shared file&#8217;s URL.  Recognizing client B as authorized on the KRO, the KMS returns the key bound to the KRO by client A in step (4).</li>
<li>Client B decrypts the shared file using the key obtained in step (6).</li>
<li>Client C performs steps (5) through (7) in the same fashion as client B.</li>
</ol>
<p id="rfc.section.3.1.p.5">It is worth noting that a race condition does exist where step (6) could occur before step (4) completes.  This will result in a client being temporarily denied access to the key used to encrypt the shared file.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#securing-an-xmpp-multi-user-chat" id="securing-an-xmpp-multi-user-chat">Securing an XMPP Multi-User Chat</a>
</h1>
<p id="rfc.section.3.2.p.1">Let A, B and C be users that wish to engage in secure chat through an existing XMPP <a href="#RFC6120" class="xref">[RFC6120]</a> multi-user chat (MUC) room.  In the context of the KMS architecture we may regard the XMPP MUC service as the resource server, the users&#8217; XMPP clients as the resource clients, and the XMPP service itself (not shown) as the KMS transport.</p>
<div id="rfc.figure.4"></div>
<div id="muc-usecase"></div>
<pre>
     XMPP           XMPP           XMPP         XMPP MUC        KMS
   Client C       Client B       Client A        Server        Server
      |              |              |              |             |
      |              |              |              |     (1)     |
      |              |              |--------------|------------&gt;|
      |              |              |              |     (2)     |
      |              |              |--------------|------------&gt;|
      |              |              |      (3)     |             |
      |              |              |-------------&gt;|             |
      |      (4)     |      (4)     |              |             |
      |&lt;-------------|&lt;-------------|--------------|             |
      |              |              |              |     (5)     |
      |              |--------------|--------------|------------&gt;|
      |              |              |              |             |
      |          (6) |              |              |             |
      |              |              |              |             |
  (7) |              |              |              |             |
</pre>
<p class="figure">Figure 4: Multi-User Chat Use Case</p>
<p id="rfc.section.3.2.p.2">This sequence begins with the assumption that a MUC room already exists on the MUC server and that each client has already established a secure channel to the KMS via authenticated key agreement.  All messages are transmitted over XMPP.</p>
<p></p>

<ol>
<li>Client A requests from the KMS some number of unbound KMS keys.  Client A selects one of these keys for encrypting MUC room messages.</li>
<li>Client A requests the creation of a KMS resource object (KRO) on the KMS to represent the MUC room.  In this message the client also requests that the key selected in step (1) be bound to the newly created KRO and that the users of clients B and C be authorized to retrieve keys bound to the KRO.</li>
<li>Client A encrypts a message with the key selected in step (1) and sends it to the MUC room.</li>
<li>The MUC service delivers client A&#8217;s encrypted message to clients B and C.</li>
<li>Client B requests from the KMS all keys bound to the KRO associated with the MUC room&#8217;s URI.  Recognizing client B as authorized on the KRO, the KMS returns the key bound to the KRO by client A in step (2).</li>
<li>Client B decrypts the shared file using the key selected in step (1).</li>
<li>Client C performs steps (5) and (6) in the same fashion as client B.</li>
</ol>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#kms-to-kms-key-federation" id="kms-to-kms-key-federation">KMS to KMS Key Federation</a>
</h1>
<p id="rfc.section.3.3.p.1">This use case illustrates two KMS instances federating keys associated with a resource.  As KMS servers are deployed to serve groups of users it is inevitable that users will want to share resources across groups or organizations.  This cross-organization sharing of keys leads to several problems.  First, each user is only known to and only knows of one logical KMS.  Second, each organization might have very different archiving requirements due to differing legal compliance regulations due to jurisdiction or industry differences.  Lastly, one or both of the users might be employees of enterprises that need to be able to respond to legal discovery requests.  To address these issues, KMS servers may federate in such a way as to allow for limited copying of keys from one KMS to another.  This permits each KMS&#8217; owning organization the ability to control the ongoing policy regarding access to keys for which their respective users are authorized.</p>
<p id="rfc.section.3.3.p.2">Let Alice@DomainA and Bob@DomainB be users of a common file sharing service and who happen to use different KMS servers to secure their communications.  Assume then that Alice wishes to share a file with Bob and therefore relies on KMS server federation to facilitate the key exchange.</p>
<div id="rfc.figure.5"></div>
<div id="fed-usecase"></div>
<pre>
HTTP Client    HTTP Client     HTTP File      KMS Server   KMS Server
Bob@DomainB   Alice@DomainA   Share Server     DomainA       DomainB
     |              |              |      (1)     |             |
     |              |--------------|-------------&gt;|             |
     |              |      (2)     |              |             |
     |              |-------------&gt;|              |             |
     |      (3)     |              |              |             |
     |&lt;-------------|--------------|              |             |
     |              |              |      (4)     |             |
     |              |--------------|-------------&gt;|             |
     |              |      (5)     |              |             |
     |--------------|-------------&gt;|              |             |
     |              |              |              |     (6)     |
     |--------------|--------------|--------------|------------&gt;|
     |              |              |              |     (7)     |
     |              |              |              |&lt;------------|
     |              |              |              |     (8)     |
     |              |              |              |&lt;------------|
     |              |              |              |             |
     |              |              |              |             | (9)
     |              |              |              |             |
(10) |              |              |              |             |
     |              |              |              |             |
</pre>
<p class="figure">Figure 5: File Sharing with KMS Federation Use Case</p>
<p id="rfc.section.3.3.p.3">This sequence begins with the assumption that each client has, at some point, already established a secure channel to their respective KMS via authenticated key agreement.</p>
<p></p>

<ol>
<li>Alice@DomainA requests from the DomainA KMS some number of unbound KMS keys.  Each KMS key is uniquely identified by a URL.</li>
<li>Alice@DomainA selects a key from the set of KMS keys obtained in step (1), uses that key to encrypt the file to be shared, and posts the encrypted content to the file sharing service.  The file sharing service responds with a URL that uniquely identifies the shared file.</li>
<li>Bob@DomainB is notified of the newly shared file URL and corresponding KMS key URL through a notification from the file sharing service (or potentially some other means, such an an email from Alice).</li>
<li>Alice@DomainA requests the creation of a KMS resource object (KRO) on the DomainA KMS to represent the shared file.  In this message Alice also requests that the KMS key from step (2) be bound to the newly created KRO and that the user Bob@DomainB be authorized to retrieve KMS keys bound to the KRO.</li>
<li>Bob@DomainB retrieves the shared file from the file sharing service.</li>
<li>Using the KMS key URL obtained in step (3), Bob@DomainB requests the KMS key from the DomainB KMS.</li>
<li>The DomainB KMS recognizes the KMS key URL as actually hosted by the DomainA KMS.  The DomainB KMS establishes a secure and mutually authenticated channel with the DomainA KMS via the KMS transport.</li>
<li>The DomainB KMS requests from the DomainA KMS the KRO object to which the KMS key is bound, along with all DomainB user authorizations and other KMS keys that have been bound to that KRO.  The DomainA KMS recognizes that the DomainB KMS is authorized to retrieve all KMS keys for which users in the DomainB domain have been authorized.  It then recognizes that at least one DomainB user (Bob) has been authorized on the KRO created in step (4).  The DomainA KMS therefore decides the DomainB KMS is authorized to make this request and returns the requested information.</li>
<li>Using the information received from the DomainA KMS, the DomainB KMS verifies that Bob@DomainB is authorized on the KRO, and satisfies the request from step (6) by returning the KMS key to Bob@DomainB.</li>
<li>Client Bob@DomainB decrypts the shared file using the key obtained in step (9).</li>
</ol>
<p id="rfc.section.3.3.p.5">Note that in step (9) the DomainB KMS is enforcing authorization policy for the KRO hosted on the DomainA KMS as it pertains to DomainB users.  This is a necessary consequence of KMS federation, where the act of authorizing access to a KRO by a user residing in a federated domain engenders an implicit trust of the KMS server that controls the federated domain.  For that reason, a KMS provider should restrict federation of its KMS servers to domains that the KMS provider regards as trusted.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#kms-protocol" id="kms-protocol">KMS Protocol</a>
</h1>
<p id="rfc.section.4.p.1">The KMS protocol is composed of a message oriented request and response API and a secure channel over which those messages are exchanged.  The API provides clients with the ability to generate E2E encryption keys, associate those keys with communications resources, and explicitly manage access authorizations on those keys.  The secure channel provides a mutually authenticated and E2E encrypted channel over which the clients and KMS server may exchange API messages securely.  The API and secure channel are described in detail through the remainder of this section.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#secure-channel" id="secure-channel">Secure Channel</a>
</h1>
<p id="rfc.section.4.1.p.1">The secure channel is an encrypted and mutually authenticated communication path between each client and the KMS server.  It transits the KMS transport which, in the context of this document, represents any service or protocol that may be utilized for the relaying of KMS API request and response messages.  This specification presumes the KMS transport to be untrusted.</p>
<div id="rfc.figure.6"></div>
<div id="establish-secure-channel"></div>
<pre>
                          (3) Secure Channel
        +===================================================+
        V                                                   V
+-----------------+  (2)   +---------------+   (1)  +---------------+
| Resource Client |&lt;------&gt;| KMS Transport |&lt;------&gt;|   KMS Server  |
+-----------------+        +---------------+        +---------------+
                      |                         |
     Trusted          |        Untrusted        |        Trusted
</pre>
<p class="figure">Figure 6: Establishment of a Secure Channel</p>
<p id="rfc.section.4.1.p.2">At a high level, the communication path between a resource client and KMS is established as follows.</p>
<p></p>

<ol>
<li>The KMS actively connects to the KMS transport.  The protocol used for this connection is out of scope for this document, however it MUST support the asynchronous flow of encrypted KMS request and response messages between the KMS and KMS transport.</li>
<li>A resource client connects to the KMS transport.  The protocol used for this connection is out of scope for this document, however it MUST support the flow of encrypted KMS request and response messages between the resource client and the KMS transport.</li>
<li>Through an elliptic curve Diffie-Helman key exchange, augmented by server and client authentication, the resource client and KMS establish a shared secret and derived ephemeral key.  This is discussed in greater detail in <a href="#proto-ecdhe" class="xref">Section 4.7.1</a>.</li>
</ol>
<p id="rfc.section.4.1.p.4">On successful mutual authentication and ephemeral key agreement, the resource client and KMS communicate through the exchange of sequenced request and response messages encrypted using the ephemeral key.</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#proto-user-identity" id="proto-user-identity">User Identity</a>
</h1>
<p id="rfc.section.4.2.p.1">Central to the KMS server&#8217;s role as a key store is its ability to restrict access to stored keying material to only authorized users.  This requires robust user authentication and a means for the unambiguous and unique identification of each user.</p>
<p id="rfc.section.4.2.p.2">Conforming KMS architecture deployments MUST rely on an identity provider that supports the generation of OAuth 2.0 <a href="#RFC6749" class="xref">[RFC6749]</a> access tokens.  The KMS server MUST rely on same identity provider for the purpose of validating access tokens received from the client.  Access tokens used by clients to demonstrate identity and authorization for access to KMS resources MUST NOT be used for any other service.  Any exposure of a KMS recognized access token to third parties (such as providers of other services) jeopardizes the security of all KMS keys for which the user whose identity is represented by the token is authorized.</p>
<p id="rfc.section.4.2.p.3">The identity provider on which the KMS server relies MAY be the same identity provider as relied upon by the resource server(s) whose communications resources are encrypted with keys managed by the KMS server.  Note, however, the reliable authentication and authorization of clients to the KMS server is critical to the security of the KMS keys it holds.  The identity provider on which the KMS relies must therefore necessarily be regarded as a trusted party within the context of the KMS architecture.</p>
<p id="rfc.section.4.2.p.4">Access tokens MUST be conveyed to the KMS server as part of the payload of encrypted KMS API requests as described in <a href="#proto-basic-request-payload" class="xref">Section 4.6.1</a> and MUST NOT be conveyed in any other manner.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#kms-identity" id="kms-identity">KMS Identity</a>
</h1>
<p id="rfc.section.4.3.p.1">Given the untrusted nature of the KMS transport by both the KMS and clients, it is critical for clients to be able to verify the identity of their KMS and ensure that no MITM attacks are carried out on client to KMS or KMS to client communications.  Therefore, the KMS MUST make use of at least one PKIX certificate <a href="#RFC5280" class="xref">[RFC5280]</a> and clients MUST validate the PKIX certificate presented by the KMS through the comparison of the certificate&#8217;s common name (CN) or subject alternative name (SAN) <a href="#RFC6125" class="xref">[RFC6125]</a> fields to the Internet domain portion of the user&#8217;s Addr-spec <a href="#RFC2822" class="xref">[RFC2822]</a> formatted unique identifier using the procedures defined in section 6 of <a href="#RFC6125" class="xref">[RFC6125]</a>.  An acceptable alternative to direct CN or SAN validation is defined in <a href="#I-D.ietf-xmpp-posh" class="xref">[I-D.ietf-xmpp-posh]</a>.</p>
<p id="rfc.section.4.3.p.2">PKIX certificates presented by the KMS can be issued by either a public or private certification authority with the stipulation that clients MUST be able to validate the KMS&#8217;s entire certificate path through the pre-established trust of the root certificate used to anchor the certificate path.  The mechanism for establishing trust of the root certificate is out of scope for this specification, but it is usually carried out through pre-installed trusted root certificates on various operating systems for public certification authorities or through enterprise endpoint management solutions or manual installation tasks for private certification authorities.</p>
<h1 id="rfc.section.4.4">
<a href="#rfc.section.4.4">4.4.</a> <a href="#object-types" id="object-types">Object Types</a>
</h1>
<p id="rfc.section.4.4.p.1">The KMS protocol defines three object types: resources, keys, and authorizations.  It is through the creation and manipulation of instances of these object types that clients interact with the KMS.</p>
<p id="rfc.section.4.4.p.2">Resource</p>
<p></p>

<ul class="empty"><li>A resource is an object that represents, within the KMS object model, a communications resource as defined in <a href="#terminology" class="xref">Section 1.1</a>.  Keys and user authorizations are associated (bound) to the resource object as a means of representing their logical association with that communications resource.</li></ul>
<p id="rfc.section.4.4.p.4">Key</p>
<p></p>

<ul class="empty"><li>A key is an object representing symmetric keying material generated and made available to authorized clients by the KMS.  A key may exist in one of two states: &#8220;bound&#8221;, and &#8220;unbound&#8221;.  An unbound key is not associated with any resource, whereas a bound key is associated with exactly one resource.</li></ul>
<p id="rfc.section.4.4.p.6">Authorization</p>
<p></p>

<ul class="empty"><li>An authorization is the association of a user with a particular resource.  When such an association exists between a user and a resource this implies that the user is entitled to retrieve any key that is bound to that resource, and to add or remove authorizations for other users on the same resource.</li></ul>
<p id="rfc.section.4.4.p.8">The KMS protocol is composed from representations of these fundamental object types.  These representations are defined in the following sections.</p>
<h1 id="rfc.section.4.4.1">
<a href="#rfc.section.4.4.1">4.4.1.</a> <a href="#proto-kms-key-object" id="proto-kms-key-object">KMS Key Objects</a>
</h1>
<p id="rfc.section.4.4.1.p.1">The JSON representations for KMS key objects is defined as follows using JSON content rules <a href="#I-D.newton-json-content-rules" class="xref">[I-D.newton-json-content-rules]</a>.</p>
<pre>
jwk : ; see [JWK]

kmsUri (
  "uri" : uri relative
)

keyRep {
  kmsUri,
  "jwk" : jwk,
  "userId" : string,
  "clientId" : string,
  "createDate" : date-time,
  "expirationDate" : date-time,
  ?"resourceUri" : kmsUri,
  ?"bindDate" : date-time
}

key (
  "key" : keyRep
)

keys (
  "keys" : [ *keyRep ]
)

keyUris (
  "keyUris" : [ *kmsUri ]
)
</pre>
<p id="rfc.section.4.4.1.p.2">The attributes of a KMS key object are defined as follows.</p>
<p id="rfc.section.4.4.1.p.3">uri</p>
<p></p>

<ul class="empty"><li>A standard definition for KMS object identifiers.</li></ul>
<p id="rfc.section.4.4.1.p.5">jwk</p>
<p></p>

<ul class="empty"><li>Symmetric keying material represented as a JWK object (see <a href="#I-D.ietf-jose-json-web-key" class="xref">[I-D.ietf-jose-json-web-key]</a>).</li></ul>
<p id="rfc.section.4.4.1.p.7">userId</p>
<p></p>

<ul class="empty"><li>The authenticated unique identifier of the user that created the key.</li></ul>
<p id="rfc.section.4.4.1.p.9">clientId</p>
<p></p>

<ul class="empty"><li>An opaque unique identifier provided by the client that created the key.</li></ul>
<p id="rfc.section.4.4.1.p.11">createDate</p>
<p></p>

<ul class="empty"><li>The point in time when the key was created, in <a href="#RFC3339" class="xref">[RFC3339]</a> date-time format.</li></ul>
<p id="rfc.section.4.4.1.p.13">expirationDate</p>
<p></p>

<ul class="empty"><li>The point in time after which the key may no longer be bound (if unbound) or may no longer be used for encrypting data (if bound or an ephemeral key).</li></ul>
<p id="rfc.section.4.4.1.p.15">resourceUri</p>
<p></p>

<ul class="empty"><li>The uri of the KMS resource object to which the key is bound.</li></ul>
<p id="rfc.section.4.4.1.p.17">bindDate</p>
<p></p>

<ul class="empty"><li>The point in time when the key was bound, in <a href="#RFC3339" class="xref">[RFC3339]</a> date-time format.</li></ul>
<h1 id="rfc.section.4.4.2">
<a href="#rfc.section.4.4.2">4.4.2.</a> <a href="#proto-kms-authorization-object" id="proto-kms-authorization-object">KMS Authorization Objects</a>
</h1>
<p id="rfc.section.4.4.2.p.1">The JSON representations for KMS authorization objects is defined as follows using JSON content rules with references to rules defined in previous sections.</p>
<pre>
authorizationRep {
  kmsUri,
  ?"authId" : string,
  ?"bearer" : string,
  "createDate" : date-time,
  "resourceUri" : kmsUri,
  ?"roleUri" : Uri
}

authorization (
  "authorization" : authorizationRep
)

authorizations (
  "authorizations" : [ *authorizationRep ]
)

authorizationUris (
  "authorizationUris" : [ *kmsUri ]
)
</pre>
<p id="rfc.section.4.4.2.p.2">The attributes of a KMS authorization object are defined as follows.</p>
<p id="rfc.section.4.4.2.p.3">uri</p>
<p></p>

<ul class="empty"><li>A standard definition for KMS object identifiers.</li></ul>
<p id="rfc.section.4.4.2.p.5">authId</p>
<p></p>

<ul class="empty"><li>A unique identifier of the authorized entity.  The exact semantics of this attribute are out of scope for this document, however it is RECOMMENDED that an implementation regard the value of this attribute as mapped to either an individual identity or a grouping of identities as recognized by the identity provider employed by the KMS.  The value of this attribute may also be the URI of a KRO, in which case all authorizations on the indicated KRO will be regarded by the KMS as also applying to the KRO to which this authorization object belongs. Either authId or bearer needs to be present, but not both.</li></ul>
<p id="rfc.section.4.4.2.p.7">bearer</p>
<p></p>

<ul class="empty"><li>A KMS generated JWT bearer token for a generated anonymous authorization that identifies the issuing KMS, the anonymous authorization ID, the KRO to which it applies, and a TTL that matches the expiration of the authorization itself. Either authId or bearer needs to be present, but not both.</li></ul>
<p id="rfc.section.4.4.2.p.9">createDate</p>
<p></p>

<ul class="empty"><li>The point in time when the authorization was created, in <a href="#RFC3339" class="xref">[RFC3339]</a> date-time format.</li></ul>
<p id="rfc.section.4.4.2.p.11">resourceUri</p>
<p></p>

<ul class="empty"><li>The object identifier of the resource to which the authorization applies.</li></ul>
<p id="rfc.section.4.4.2.p.13">roleUri</p>
<p></p>

<ul class="empty"><li>An identifier in the form of Uri to specify the role of the authorization, could be participant, cloudAgent, orgAgent, etc. by default without the roleUri explicitly specified, it is participant role.</li></ul>
<p id="rfc.section.4.4.2.p.15">Note, with respect to this specification user identifiers are opaque, however they MUST map to unique identifiers provided as part of user authentication.</p>
<h1 id="rfc.section.4.4.3">
<a href="#rfc.section.4.4.3">4.4.3.</a> <a href="#proto-kms-resource-object" id="proto-kms-resource-object">KMS Resource Objects (KRO)</a>
</h1>
<p id="rfc.section.4.4.3.p.1">The JSON representation for KMS resource objects is defined as follows using JSON content rules with references to rules defined in previous sections.</p>
<pre>
resourceRep {
  kmsUri,
  keys / keyUris,
  authorizations / authorizationUris,
  ttl
}

resource (
  "resource" : resourceRep
)

resources (
  "resources" : [ *resourceRep ]
)

resourceUris (
  "resourceUris" : [ *kmsUri ]
)
</pre>
<p id="rfc.section.4.4.3.p.2">The attributes of a KMS resource object are defined as follows.</p>
<p id="rfc.section.4.4.3.p.3">uri</p>
<p></p>

<ul class="empty"><li>A standard definition for KMS object identifiers.</li></ul>
<p id="rfc.section.4.4.3.p.5">keys</p>
<p></p>

<ul class="empty"><li>An array of key object representations, one for each key bound to the resource.</li></ul>
<p id="rfc.section.4.4.3.p.7">keyUris</p>
<p></p>

<ul class="empty"><li>An array of key object identifiers, one for each key bound to the resource.  Only one of either keys or keyUris may be present in a resource object representation.</li></ul>
<p id="rfc.section.4.4.3.p.9">authorizations</p>
<p></p>

<ul class="empty"><li>An array of authorization object representations, one for each authorization on the resource.</li></ul>
<p id="rfc.section.4.4.3.p.11">authorizationUris</p>
<p></p>

<ul class="empty"><li>An array of authorization object identifiers, one for each authorization on the resource.  Only one of either authorizations or authorizationUris may be present in a resource object representation.</li></ul>
<h1 id="rfc.section.4.5">
<a href="#rfc.section.4.5">4.5.</a> <a href="#request-types" id="request-types">Request Types</a>
</h1>
<p id="rfc.section.4.5.p.1">The KMS protocol defines four types of requests: create, retrieve, update, delete, each of which may be applied to one of the three KMS object types.  Note that not all object types support all requests types.  A KMS need only support those combinations of request type and object type explicitly defined in this document.</p>
<p id="rfc.section.4.5.p.2">Create</p>
<p></p>

<ul class="empty"><li>A create operation acts upon an object type, creating one or more new instances of that object type.</li></ul>
<p id="rfc.section.4.5.p.4">Retrieve</p>
<p></p>

<ul class="empty"><li>A retrieve operation acts upon an object or object type, returning in the response a representation of one or more object instances.</li></ul>
<p id="rfc.section.4.5.p.6">Update</p>
<p></p>

<ul class="empty"><li>An update operation acts upon an object, altering mutable properties of that object.</li></ul>
<p id="rfc.section.4.5.p.8">Delete</p>
<p></p>

<ul class="empty"><li>A delete operation acts upon an object, removing that object from the KMS.</li></ul>
<h1 id="rfc.section.4.6">
<a href="#rfc.section.4.6">4.6.</a> <a href="#message-structure" id="message-structure">Message Structure</a>
</h1>
<p id="rfc.section.4.6.p.1">Every KMS request and response message is composed of a JSON <a href="#RFC7159" class="xref">[RFC7159]</a> formatted payload encapsulated within either a JWE <a href="#I-D.ietf-jose-json-web-encryption" class="xref">[I-D.ietf-jose-json-web-encryption]</a> or JWS <a href="#I-D.ietf-jose-json-web-signature" class="xref">[I-D.ietf-jose-json-web-signature]</a> object.  These messages may be divided into three types.</p>
<p id="rfc.section.4.6.p.2">Common Messages</p>
<p></p>

<ul class="empty"><li>Common messages include all those which do not meet the definition of either key agreement message or error message.  Common messages are encrypted as JWE objects using the shared ephemeral key established during initial key agreement between the client and KMS (see <a href="#proto-ecdhe" class="xref">Section 4.7.1</a>).  The value of the JWE header &#8220;kid&#8221; attribute of a common message MUST match that of the KMS ephemeral key object URI attribute established during initial key agreement.</li></ul>
<p id="rfc.section.4.6.p.4">Ephemeral Key Agreement Messages</p>
<p></p>

<ul class="empty"><li>Ephemeral key agreement messages are those exchanged between the client and KMS for the purpose of establishing a new shared ephemeral key (see <a href="#proto-ecdhe" class="xref">Section 4.7.1</a>).  Key agreement request payloads are encrypted as JWE objects using the authenticated and validated static public key of the KMS.  Key agreement response payloads are signed as JWS objects using the static private key of the KMS.  The value of the JWE or JWS header &#8220;kid&#8221; attribute of an ephemeral key agreement message MUST be a well known key identifier for the KMS static public key.</li></ul>
<p id="rfc.section.4.6.p.6">Error Messages</p>
<p></p>

<ul class="empty"><li>Error messages are those originated by the KMS to indicate a failed request.  Error messages are composed in the same fashion as common messages; however, in the event that the KMS does not recognize the ephemeral key used in the request, or that key is determined to have expired, the KMS MUST respond with an unencrypted message composed as a JWS, with a payload as described in <a href="#proto-error" class="xref">Section 4.6.3</a>, and signed using the KMS server&#8217;s static public key.</li></ul>
<p id="rfc.section.4.6.p.8">The basic JSON representations for the request and response payloads are defined in the following sections.</p>
<h1 id="rfc.section.4.6.1">
<a href="#rfc.section.4.6.1">4.6.1.</a> <a href="#proto-basic-request-payload" id="proto-basic-request-payload">Basic Request Payload</a>
</h1>
<p id="rfc.section.4.6.1.p.1">The basic JSON representation for KMS request message payloads is defined as follows using JSON content rules with references to rules defined in previous sections.</p>
<pre>
requestId (
  "requestId" : integer
)

credential {
  "userId": ?string
  "bearer": string / "jwk": jwk
}

client {
  "clientId": string,
  "credential": credential
)

method: string /create|retrieve|update|delete/

request (
  "client" : client,
  "method" : method,
  kmsUri,
  requestId
)
</pre>
<p id="rfc.section.4.6.1.p.2">The attributes of a KMS request message payload are defined as follows.</p>
<p id="rfc.section.4.6.1.p.3">requestId</p>
<p></p>

<ul class="empty"><li>A string selected by the client and provided in each request to uniquely identify the request.  The string is treated opaquely by the server and returned verbatim in the associated response.</li></ul>
<p id="rfc.section.4.6.1.p.5">userId</p>
<p></p>

<ul class="empty"><li>The unique identifier of the user making the request.  This field is optional, and MUST be disregarded if the requesting user&#8217;s identity can be securely derived from either the bearer token or jwk.</li></ul>
<p id="rfc.section.4.6.1.p.7">bearer</p>
<p></p>

<ul class="empty"><li>An <a href="#RFC6749" class="xref">[RFC6749]</a> access token issued by the client&#8217;s identity provider and validated by the KMS in cooperation with the identity provider.  See <a href="#proto-user-identity" class="xref">Section 4.2</a>.</li></ul>
<p id="rfc.section.4.6.1.p.9">jwk</p>
<p></p>

<ul class="empty"><li>A JWK object, in JSON format as defined in <a href="#I-D.ietf-jose-json-web-key" class="xref">[I-D.ietf-jose-json-web-key]</a>, containing the public key of the client (presumably a server).  This JWK MUST contain an x5c header with a certificate chain that may be used to positively validate the public key.</li></ul>
<p id="rfc.section.4.6.1.p.11">clientId</p>
<p></p>

<ul class="empty"><li>An opaque unique identifier provided by the client (not used for authentication, only to assist multiple clients of a single user in differentiating between their respective unbound keys).</li></ul>
<p id="rfc.section.4.6.1.p.13">method</p>
<p></p>

<ul class="empty"><li>Indicates the request type: create, retrieve, update, or delete.</li></ul>
<p id="rfc.section.4.6.1.p.15">uri</p>
<p></p>

<ul class="empty"><li>The KMS object or object type to which the request applies.</li></ul>
<p id="rfc.section.4.6.1.p.17">The JSON content rules above are used in conjunction with additional request type specific rules, defined later in this document, to produce the full request payload definition for each KMS operation.</p>
<h1 id="rfc.section.4.6.2">
<a href="#rfc.section.4.6.2">4.6.2.</a> <a href="#proto-basic-response-payload" id="proto-basic-response-payload">Basic Response Payload</a>
</h1>
<p id="rfc.section.4.6.2.p.1">The basic JSON representation for KMS request message payloads is defined as follows using JSON content rules with references to rules defined in previous sections.</p>
<pre>
response (
  "status" : integer,
  ?"reason" : string,
  requestId
)
</pre>
<p id="rfc.section.4.6.2.p.2">The attributes of a KMS request message payload are defined as follows.</p>
<p id="rfc.section.4.6.2.p.3">status</p>
<p></p>

<ul class="empty"><li>Indicates the success or failure of the request.  The value returned in a response status attribute SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the success or failure condition of the KMS request.</li></ul>
<p id="rfc.section.4.6.2.p.5">reason</p>
<p></p>

<ul class="empty"><li>An optional natural language string to describe the response status in terms that are useful for tracing and troubleshooting the API.</li></ul>
<p id="rfc.section.4.6.2.p.7">requestId</p>
<p></p>

<ul class="empty"><li>An echo of the requestId provided in the request.</li></ul>
<p id="rfc.section.4.6.2.p.9">The JSON content rules above are used in conjunction with additional response type specific rules, defined later in this document, to produce the full response payload definition for each KMS operation.</p>
<h1 id="rfc.section.4.6.3">
<a href="#rfc.section.4.6.3">4.6.3.</a> <a href="#proto-error" id="proto-error">Error Response Payload</a>
</h1>
<p id="rfc.section.4.6.3.p.1">The JSON representation for KMS error response message payloads is defined as follows using JSON content rules with references to rules defined in previous sections.</p>
<p id="rfc.section.4.6.3.p.2">Error response payload definition:</p>
<pre>
root {
  response
}
</pre>
<p id="rfc.section.4.6.3.p.3">Error response message example:</p>
<pre>
JWS(K_kms_priv, {
  "status": 403,
  "reason": "The ephemeral key used in the request has expired.",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5"
})
</pre>
<h1 id="rfc.section.4.7">
<a href="#rfc.section.4.7">4.7.</a> <a href="#requests" id="requests">Requests</a>
</h1>
<p id="rfc.section.4.7.p.1">The following sections provide detailed descriptions for each of the request and response operations that may occur between a resource client and the KMS.</p>
<h1 id="rfc.section.4.7.1">
<a href="#rfc.section.4.7.1">4.7.1.</a> <a href="#proto-ecdhe" id="proto-ecdhe">Create Ephemeral Key</a>
</h1>
<p id="rfc.section.4.7.1.p.1">The first operation between a client and KMS MUST be the establishment of a shared secret and derived ephemeral key.  This is necessary as all other requests and responses are encrypted with the ephemeral key.</p>
<p id="rfc.section.4.7.1.p.2">The client request for creating an ephemeral key conforms to the basic request message payload, where the method is &#8220;create&#8221; and the uri is &#8220;/ecdhe&#8221;.  In addition to the basic payload, the client provides a jwk attribute for which the value is a JWK object <a href="#I-D.ietf-jose-json-web-key" class="xref">[I-D.ietf-jose-json-web-key]</a> containing the public part of an EC key pair generated by the client.  Unlike a basic request message, however, the request payload is encrypted as the content of a JWE <a href="#I-D.ietf-jose-json-web-key" class="xref">[I-D.ietf-jose-json-web-key]</a> object secured with the static public key of the KMS server (K_kms_pub) as obtained from the server&#8217;s validated PKIX certificate <a href="#RFC5280" class="xref">[RFC5280]</a>.</p>
<p id="rfc.section.4.7.1.p.3">Note, the client MUST generate a new EC key pair for every create ephemeral key request sent to the KMS server.</p>
<p id="rfc.section.4.7.1.p.4">Request payload definition:</p>
<pre>
root {
  request,
  jwk
}
</pre>
<p id="rfc.section.4.7.1.p.5">Request message example:</p>
<pre>
JWE(K_kms_pub, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }, 
  "method": "create",
  "uri": "/ecdhe",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "jwk" : {
    "kty": "EC",
    "crv": "P-256",
    "x": "VoFkf6Wk5kDQ1ob6csBmiMPHU8jALwdtaap35Fsj20M",
    "y": "XymwN6u2PmsKbIPy5iij6qZ-mIyej5dvZWB_75lnRgQ"
  }
})
</pre>
<p id="rfc.section.4.7.1.p.6">On receiving the ephemeral key creation request, the KMS server MUST verify the credential provided in the request.  If a bearer token is provided, the KMS MUST validate the token in cooperation with the identity provider.  If a jwk is provided, the KMS MUST validate the included PKIX certificate chain against the KMS server&#8217;s trust root.  In either case, the identity of the requesting client MUST be authenticated and verified to correspond to either an authorized user of the KMS or an authorized trusted service.  If verification fails, the KMS MUST NOT use the server response to continue with key agreement.</p>
<p id="rfc.section.4.7.1.p.7">Upon successful authentication and authorization of the request, the KMS responds by generating its own EC key pair using the same curve as indicated in the &#8220;crv&#8221; attribute of the request message JWK.  The KMS server returns the public part of this key pair to the resource client in the form of a KMS key object within the response payload.  The KMS also generates and includes within the response payload a new key uri to be regarded by both client and KMS as the key identifier of the agreed upon ephemeral key.  The response payload is returned to the resource client as the content of a JWS <a href="#I-D.ietf-jose-json-web-signature" class="xref">[I-D.ietf-jose-json-web-signature]</a> signed using the static private key of the KMS server (K_kms_priv).</p>
<p id="rfc.section.4.7.1.p.8">Response payload definition:</p>
<pre>
root {
  response,
  key
}
</pre>
<p id="rfc.section.4.7.1.p.9">Response message example:</p>
<pre>
JWS(K_kms_priv, {
  "status": 201,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "key": {
    "uri": "/ecdhe/ea9f3858-1240-4328-ae22-a15f6072306f",
    "jwk" : {
      "kty": "EC",
      "crv": "P-256",
      "x": "8mdasnEZac2LWxMwKExikKU5LLacLQlcOt7A6n1ZGUC",
      "y": "lxs7ln5LtZUE_GE7yzc6BZOwBxtOftdsr8HVh-14ksS"
    },
    "userId": "842e2d82-7e71-4040-8eb9-d977fe888807",
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "createDate": "2014-10-09T15:54:48Z",
    "expirationDate": "2014-10-09T16:54:48Z"
  }
})
</pre>
<p id="rfc.section.4.7.1.p.10">If successful, the KMS response to a create ephemeral key request MUST have a status of 201.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.  In addition, the ephemeral key SHOULD have the createDate assigned as the current time and an expirationDate assigned as the latest point in time before which the key may be used for encrypting messages (both in <a href="#RFC3339" class="xref">[RFC3339]</a> date-time format).</p>
<p id="rfc.section.4.7.1.p.11">On receiving the ephemeral key creation response, the resource client MUST verify the received JWS against the KMS server&#8217;s validated static public key.  If verification fails, the client MUST NOT use the server response to continue with key agreement.</p>
<p id="rfc.section.4.7.1.p.12">To generate the shared secret, both resource client and KMS server use ECDH shared secret derivation with the private part of the local EC key pair and the public part of the remote EC key pair.  The shared secret is then provided as input to HKDF (with both extract and expand, and empty salt) <a href="#RFC5869" class="xref">[RFC5869]</a> to generate the ephemeral key (K_ephemeral).</p>
<p id="rfc.section.4.7.1.p.13">The ephemeral key generated by this operation is used to encrypt all subsequent KMS requests and responses passed between the resource client and KMS.  When encrypting such a message, the sender MUST assign a value to the kid attribute of the header of the resulting JWE object, and this value MUST match the URL of the key as provided to the client in the KMS response message described above.  This provides the recipient with a means for identifying the key necessary to decrypt the message.</p>
<p id="rfc.section.4.7.1.p.14">The KMS SHOULD accept messages encrypted with the ephemeral key up to and until the key expiration date as provided in the response message described above.  On expiration of the ephemeral key, the KMS MUST reject all further requests submitted using this key, and a client wishing to submit further requests to the KMS MUST re-establish the secure channel by requesting the creation of a new ephemeral key.</p>
<h1 id="rfc.section.4.7.2">
<a href="#rfc.section.4.7.2">4.7.2.</a> <a href="#delete-ephemeral-key" id="delete-ephemeral-key">Delete Ephemeral Key</a>
</h1>
<p id="rfc.section.4.7.2.p.1">In the event that a resource client&#8217;s ephemeral key has become compromised, a client SHOULD submit a request to the KMS to delete the ephemeral key.</p>
<p id="rfc.section.4.7.2.p.2">The request message conforms to the basic request message structure, where the method is &#8220;delete&#8221;, and the uri is that of the ephemeral key to be deleted.</p>
<p id="rfc.section.4.7.2.p.3">Request payload definition:</p>
<pre>
root {
  request
}
</pre>
<p id="rfc.section.4.7.2.p.4">Request message example:</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "delete",
  "uri": "/ecdhe/ea9f3858-1240-4328-ae22-a15f6072306f",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5"
})
</pre>
<p id="rfc.section.4.7.2.p.5">The response message conforms to the basic response message structure, and MUST NOT include a representation of the deleted ephemeral key.</p>
<p id="rfc.section.4.7.2.p.6">Response payload definition:</p>
<pre>
root {
  response
}
</pre>
<p id="rfc.section.4.7.2.p.7">Response message example:</p>
<pre>
JWE(K_ephemeral, {
  "status": 204,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5"
})
</pre>
<p id="rfc.section.4.7.2.p.8">If successful, the KMS response to a delete ephemeral key request MUST have a status of 204.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.</p>
<p id="rfc.section.4.7.2.p.9">On successful deletion of an ephemeral key, the KMS MUST NOT, from that time forward, accept any requests encrypted with that ephemeral key.</p>
<h1 id="rfc.section.4.7.3">
<a href="#rfc.section.4.7.3">4.7.3.</a> <a href="#create-resource" id="create-resource">Create Resource</a>
</h1>
<p id="rfc.section.4.7.3.p.1">When a client intends to initiate E2E encryption of a communications resource, it begins by requesting the creation of a KMS resource object.  This resource object logically represents the communications resource within the KMS data model.</p>
<p id="rfc.section.4.7.3.p.2">As part of a create resource request, a KMS server MUST create at least one authorization object on the newly created resource object to explicitly authorize the user making the request.  A client MAY request the immediate creation of one or more additional authorizations such that corresponding users may be immediately authorized to access and operate on the new resource object. Also, a client MAY request number of anonymous authorizations to be created on the new resource object, specified by anonymous attribute in the request. If for any reason one or more requested authorizations cannot be applied to the new resource object, the entire create resource request MUST be failed by the KMS.</p>
<p id="rfc.section.4.7.3.p.3">As part of a create resource request, a client MAY request the immediate binding of one or more unbound KMS keys to the new resource object.  If any key indicated in the request is already bound, or is otherwise invalid (e.g. expired), the entire create resource request MUST be failed by the KMS.</p>
<p id="rfc.section.4.7.3.p.4">Also, the client MAY request a time to live for the new resource object. The TTL is in seconds with a default of 0 (never expires). Implementations MAY enforce minimum and/or maximum values for TTL. If a requested TTL value is not within the server&#8217;s acceptable range, it SHOULD respond with a 400 and response message indicating the server&#8217;s acceptable range.</p>
<p id="rfc.section.4.7.3.p.5">The request message conforms to the basic request message structure, where the method is &#8220;create&#8221;, the uri is &#8220;/resources&#8221;, and additional user identifiers and/or key URIs are provided in a manner consistent with the following.</p>
<p id="rfc.section.4.7.3.p.6">Request payload definition:</p>
<pre>
authIds (
  "authIds" : [ *string ]
)

root {
  request,
  ?authIds,
  ?anonymous,
  ?keyUris,
  ?ttl
}
</pre>
<p id="rfc.section.4.7.3.p.7">Request message example:</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "create",
  "uri": "/resources",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "authIds": [
    "b46e8124-b6e8-47e0-af0d-e7f1a2072dac",
    "39d56a84-c6f9-459e-9fd1-40ab4ad3e89a"
  ],
  "keyUris": [
    "/keys/b4cba4da-a984-4af2-b54f-3ca04acfe461",
    "/keys/2671413c-ab80-4f19-a0a4-ae07e1a94e90"
  ],
  "ttl": 604800
})
</pre>
<p id="rfc.section.4.7.3.p.8">The response message conforms to the basic response message structure, and includes a representation of the created KMS resource object.</p>
<p id="rfc.section.4.7.3.p.9">Response payload definition:</p>
<pre>
root {
  response,
  resource
}
</pre>
<p id="rfc.section.4.7.3.p.10">Response message example:</p>
<pre>
JWE(K_ephemeral, {
  "status": 201,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "resource": {
      "uri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094",
      "authorizationUris": [
        "/authorizations/50e9056d-0700-4919-b55f-84cd78a2a65e",
        "/authorizations/db4c95ab-3fbf-42a8-989f-f53c1f13cc9a"
      ],
      "keyUris": [
        "/keys/b4cba4da-a984-4af2-b54f-3ca04acfe461",
        "/keys/2671413c-ab80-4f19-a0a4-ae07e1a94e90"
      ],
      "expirationDate": "2014-10-09T16:54:48Z"
  }
})
</pre>
<p id="rfc.section.4.7.3.p.11">If successful, the KMS response to a create resource request MUST have a status of 201.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.</p>
<h1 id="rfc.section.4.7.4">
<a href="#rfc.section.4.7.4">4.7.4.</a> <a href="#retrieve-resource" id="retrieve-resource">Retrieve Resource</a>
</h1>
<p id="rfc.section.4.7.4.p.1">A client that is authorized on a given KMS resource object may retrieve the current state of that object as well as that of current set of KMS authorization objects and bound KMS keys.</p>
<p id="rfc.section.4.7.4.p.2">The request message conforms to the basic request message structure, where the method is &#8220;retrieve&#8221;, and the uri is that of the KMS resource object as returned by the create operation from which it originated.</p>
<p id="rfc.section.4.7.4.p.3">Request payload definition:</p>
<pre>
root {
  request
}
</pre>
<p id="rfc.section.4.7.4.p.4">Request message example:</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "retrieve",
  "uri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094",
  "requestId": "db1e4d2a-d483-4fe7-a802-ec5c0d32295f",
})
</pre>
<p id="rfc.section.4.7.4.p.5">The response message conforms to the basic response message structure, and includes a representation of the retrieved KMS resource object.</p>
<p id="rfc.section.4.7.4.p.6">Response payload definition:</p>
<pre>
root {
  response,
  resource
}
</pre>
<p id="rfc.section.4.7.4.p.7">Response message example:</p>
<pre>
JWE(K_ephemeral, {
  "status": 200,
  "requestId": "db1e4d2a-d483-4fe7-a802-ec5c0d32295f",
  "resource": {
      "uri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094",
      "authorizationUris": [
        "/authorizations/50e9056d-0700-4919-b55f-84cd78a2a65e",
        "/authorizations/db4c95ab-3fbf-42a8-989f-f53c1f13cc9a"
      ],
      "keyUris": [
        "/keys/b4cba4da-a984-4af2-b54f-3ca04acfe461",
        "/keys/2671413c-ab80-4f19-a0a4-ae07e1a94e90"
      ]
  }
})
</pre>
<p id="rfc.section.4.7.4.p.8">If successful, the KMS response to a retrieve resource request MUST have a status of 200.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.</p>
<h1 id="rfc.section.4.7.5">
<a href="#rfc.section.4.7.5">4.7.5.</a> <a href="#create-keys" id="create-keys">Create Keys</a>
</h1>
<p id="rfc.section.4.7.5.p.1">When a client requires a symmetric key for use in the E2E encryption of a communications resource, it begins by requesting the creation of one or more keys from the KMS.  The initial state of a newly created key is &#8220;unbound&#8221; in the sense that it does not yet belong to a particular resource.  A client may submit this request at any time, even before the communications resource exists.  The keys returned by this request are unbound, which is to say not yet associated with any KMS resource object.</p>
<p id="rfc.section.4.7.5.p.2">The request message conforms to the basic request message structure, where the method is &#8220;create&#8221;, the uri is &#8220;/keys&#8221;, and an additional count attribute is introduced to indicate the number of keys to be created.</p>
<p id="rfc.section.4.7.5.p.3">Request payload definition:</p>
<pre>
root {
  request,
  "count": integer
}
</pre>
<p id="rfc.section.4.7.5.p.4">Request message example:</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "create",
  "uri": "/keys",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "count": 2  
})
</pre>
<p id="rfc.section.4.7.5.p.5">The response message conforms to the basic response message structure with the addition of an array of key object representations, one for each unbound key created.</p>
<p id="rfc.section.4.7.5.p.6">Response payload definition:</p>
<pre>
root {
  response,
  keys / keyUris
}
</pre>
<p id="rfc.section.4.7.5.p.7">Response message example:</p>
<pre>
JWE(K_ephemeral, {
  "status": 201,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "keys": [
    {
      "uri": "/keys/52100fa4-c222-46d0-994d-1ca885e4a3a2",
      "jwk": {
        "kid": "52100fa4-c222-46d0-994d-1ca885e4a3a2",
        "kty": "oct",
        "k": "ZMpktzGq1g6_r4fKVdnx9OaYr4HjxPjIs7l7SwAsgsg"
      }
      "userId": "842e2d82-7e71-4040-8eb9-d977fe888807",
      "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
      "createDate": "2014-10-09T15:54:48Z",
      "expirationDate": "2014-10-09T16:04:48Z"
    },
    {
      "uri": "/keys/fed33890-f9fa-43ad-a9f8-ab55a983a543",
      "jwk": {
        "kid": "fed33890-f9fa-43ad-a9f8-ab55a983a543",
        "kty": "oct",
        "k": "q2znCXQpbBPSZBUddZvchRSH5pSSKPEHlgb3CSGIdpL"
      }
      "userId": "842e2d82-7e71-4040-8eb9-d977fe888807",
      "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
      "createDate": "2014-10-09T15:54:48Z",
      "expirationDate": "2014-10-09T16:04:48Z"
    }
  ]
})
</pre>
<p id="rfc.section.4.7.5.p.8">Each key object in the response to a create unbound keys request includes a single JWK <a href="#I-D.ietf-jose-json-web-key" class="xref">[I-D.ietf-jose-json-web-key]</a> representing a new symmetric key of 256 bits generated by a cryptographically secure PRNG.  Note that, as unbound keys, the resourceUri attribute of each key is either undefined or null.  All keys SHOULD have the createDate assigned as the current time and an expirationDate assigned as the latest point in time before which the key may be bound to a resource (both in <a href="#RFC3339" class="xref">[RFC3339]</a> date-time format).</p>
<p id="rfc.section.4.7.5.p.9">The clientId attribute of each created key MUST be the clientId provided by the client in the client.clientId attribute of the request.</p>
<p id="rfc.section.4.7.5.p.10">As shown in the response payload definition, the KMS MUST return either an array of key object representations or an array of key object uris.  It is at the KMS server&#8217;s discretion which of these is returned.</p>
<p id="rfc.section.4.7.5.p.11">If successful, the KMS response to a create unbound keys request MUST have a status of 201.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.</p>
<h1 id="rfc.section.4.7.6">
<a href="#rfc.section.4.7.6">4.7.6.</a> <a href="#update-key-bind" id="update-key-bind">Update Key (Bind)</a>
</h1>
<p id="rfc.section.4.7.6.p.1">To initiate the use of an unbound KMS key in securing a communications resource, a client will create a corresponding KMS resource object and subsequently bind the unbound key to that resource.  A client MAY begin using an unbound KMS key to encrypt a communications resource prior to the binding of that key.</p>
<p id="rfc.section.4.7.6.p.2">The request message conforms to the basic request message structure, where the method is &#8220;update&#8221;, the uri is that of the key to be bound, and an additional resourceUri attribute is introduced to indicate the KMS resource object to which the key is to be bound.  If the user making a bind unbound key request does not have an authorization on the resource indicated by the resourceUri, or is not the user for whom the unbound key was originally created, the KMS MUST fail the request.  The KMS SHOULD fail the request if the clientId of the request does not match that of the unbound key.</p>
<p id="rfc.section.4.7.6.p.3">Request payload definition:</p>
<pre>
root {
  request,
  "resourceUri" : kmsUri
}
</pre>
<p id="rfc.section.4.7.6.p.4">Request message example:</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "update",
  "uri": "/keys/52100fa4-c222-46d0-994d-1ca885e4a3a2",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094"
})
</pre>
<p id="rfc.section.4.7.6.p.5">The response message conforms to the basic response message structure, and includes a representation of the full state of the newly bound key.</p>
<p id="rfc.section.4.7.6.p.6">Response payload definition:</p>
<pre>
root {
  response,
  key
}
</pre>
<p id="rfc.section.4.7.6.p.7">Response message example:</p>
<pre>
JWE(K_ephemeral, {
{
  "status": 200,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "key": {
    "uri": "/keys/52100fa4-c222-46d0-994d-1ca885e4a3a2",
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "jwk": {
      "kid": "52100fa4-c222-46d0-994d-1ca885e4a3a2",
      "kty": "oct",
      "k": "ZMpktzGq1g6_r4fKVdnx9OaYr4HjxPjIs7l7SwAsgsg"
    }
    "userId": "842e2d82-7e71-4040-8eb9-d977fe888807",
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "createDate": "2014-10-09T15:54:48Z",
    "bindDate": "2014-10-09T15:55:34Z",
    "expirationDate": "2014-10-10T15:55:34Z",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094"
  }
})
</pre>
<p id="rfc.section.4.7.6.p.8">On successfully binding a formerly unbound KMS key to a resource object, the state of the KMS key object MUST reflect the updated resourceUri attribute,  MUST reflect a bindDate as the current time, and MUST reflect an expirationDate as the time after which clients MUST NOT use this key for encryption as provided by KMS policy.  Subsequently, the KMS MUST regard the key as bound to the KMS resource object identified by the resourceUri and MUST reject subsequent requests to bind the same key to any other resource object.</p>
<p id="rfc.section.4.7.6.p.9">If successful, the KMS response to a bind unbound key request MUST have a status of 200.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.</p>
<h1 id="rfc.section.4.7.7">
<a href="#rfc.section.4.7.7">4.7.7.</a> <a href="#retrieve-keys" id="retrieve-keys">Retrieve Keys</a>
</h1>
<p id="rfc.section.4.7.7.p.1">Clients engaging in E2E encryption require a means for retrieving keys from the KMS.  A key request may take one of three forms, it may be a request for</p>
<p></p>

<ul>
<li>a specific key,</li>
<li>all keys bound to a particular resource,</li>
<li>a subset of keys bound to a particular resource.</li>
</ul>
<p id="rfc.section.4.7.7.p.3">In all cases, the request message conforms to the basic request message structure with &#8220;retrieve&#8221; as the value for the method attribute.</p>
<p id="rfc.section.4.7.7.p.4">To retrieve an individual key, the uri of the request is that of the key object to be retrieved.  If the key is unbound, the KMS MUST reject the request unless it originates from the user that requested the key&#8217;s creation, and SHOULD reject the request unless it originates from the same client that requested the key&#8217;s creation (as determined by clientId).  If the key is bound, the KMS MUST reject the request if the request originates from a user for which there does not exist a corresponding authorization on the resource to which the requested key is bound.</p>
<p id="rfc.section.4.7.7.p.5">To retrieve all keys bound to a resource, the uri of the request is that of the resource concatenated with &#8220;/keys&#8221;.  The KMS MUST reject the request if the request originates from a user for which there does not exist a corresponding authorization on the resource.</p>
<p id="rfc.section.4.7.7.p.6">To retrieve a subset of keys bound to a resource, the client submits a request in the same fashion as for requesting all keys but also includes one or more additional attributes indicating selection criteria.  These additional attributes include the following:</p>
<p></p>

<ul>
<li>boundAfter</li>
<li>boundBefore</li>
</ul>
<p id="rfc.section.4.7.7.p.8">Each of these parameters is optional and clients MAY employ them in any combination.</p>
<p id="rfc.section.4.7.7.p.9">If the request includes a &#8220;boundAfter&#8221; attribute, the value MUST conform to the <a href="#RFC3339" class="xref">[RFC3339]</a> date-time format and the KMS response MUST NOT include any key with a &#8220;bindDate&#8221; that chronologically precedes it.  Similarly, if the request includes a &#8220;boundBefore&#8221; attribute, the value MUST conform to the <a href="#RFC3339" class="xref">[RFC3339]</a> date-time format and the KMS response MUST NOT include any key with a &#8220;bindDate&#8221; that is either equal to or chronologically subsequent to it.</p>
<p id="rfc.section.4.7.7.p.10">To limit the number of keys returned in a KMS response, a client MAY include a &#8220;count&#8221; attribute.  If the request includes a &#8220;count&#8221; attribute, it must be of JSON type integer and the cardinality of the set of keys returned in the KMS response MUST NOT exceed its value.  In the event it becomes necessary for the KMS to truncate the set of keys included in the KMS response, due to the limitations imposed by the &#8220;count&#8221; attribute, the truncated subset MUST be composed of those keys which satisfy the request&#8217;s other selection criteria (if any) and also constitute a subset of that selection for which the elements possess the chronologically largest &#8220;bindDate&#8221; values.</p>
<p id="rfc.section.4.7.7.p.11">Request payload definition:</p>
<pre>
root {
  request,
  ?"boundAfter" : date-time,
  ?"boundBefore" : date-time,
  ?"count" : integer
}
</pre>
<p id="rfc.section.4.7.7.p.12">Request message example (individual key):</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "retrieve",
  "uri": "/keys/52100fa4-c222-46d0-994d-1ca885e4a3a2",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5"
})
</pre>
<p id="rfc.section.4.7.7.p.13">Request message example (10 most recently bound keys):</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "retrieve",
  "uri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094/keys",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "count": 10
})
</pre>
<p id="rfc.section.4.7.7.p.14">Request message example (keys bound after a given time, 25 max):</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "retrieve",
  "uri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094/keys",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "boundAfter": "2015-01-11T18:23:21Z",
  "count": 25
})
</pre>
<p id="rfc.section.4.7.7.p.15">The response message conforms to the basic response message structure and includes a representation of the key or keys selected by the request.  When responding to a request for a specific key, the KMS will return a response that includes a KMS key object representation as described in <a href="#proto-kms-key-object" class="xref">Section 4.4.1</a>.  When responding to a request for multiple keys, the KMS will return a response that includes an array of KMS key object representations.</p>
<p id="rfc.section.4.7.7.p.16">Response payload definition:</p>
<pre>
root {
  response,
  key / keys
}
</pre>
<p id="rfc.section.4.7.7.p.17">Response message example (for specific key):</p>
<pre>
JWE(K_ephemeral, {
{
  "status": 200,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "key": {
    "uri": "/keys/52100fa4-c222-46d0-994d-1ca885e4a3a2",
    "jwk": {
      "kid": "52100fa4-c222-46d0-994d-1ca885e4a3a2",
      "kty": "oct",
      "k": "ZMpktzGq1g6_r4fKVdnx9OaYr4HjxPjIs7l7SwAsgsg"
    }
    "userId": "842e2d82-7e71-4040-8eb9-d977fe888807",
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "createDate": "2014-10-09T15:54:48Z",
    "bindDate": "2014-10-09T15:55:34Z",
    "expirationDate": "2014-10-10T15:55:34Z",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094"
  }
})
</pre>
<p id="rfc.section.4.7.7.p.18">Response message example (for keys bound to a specific resource):</p>
<pre>
JWE(K_ephemeral, {
{
  "status": 200,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "keys": [
  {
    "uri": "/keys/52100fa4-c222-46d0-994d-1ca885e4a3a2",
    "jwk": {
      "kid": "52100fa4-c222-46d0-994d-1ca885e4a3a2",
      "kty": "oct",
      "k": "ZMpktzGq1g6_r4fKVdnx9OaYr4HjxPjIs7l7SwAsgsg"
    }
    "userId": "842e2d82-7e71-4040-8eb9-d977fe888807",
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "createDate": "2014-10-09T15:54:48Z",
    "bindDate": "2014-10-09T15:55:34Z",
    "expirationDate": "2014-10-10T15:55:34Z",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094"
  },
  {
    "uri": "/keys/fed33890-f9fa-43ad-a9f8-ab55a983a543",
    "jwk": {
      "kid": "fed33890-f9fa-43ad-a9f8-ab55a983a543",
      "kty": "oct",
      "k": "q2znCXQpbBPSZBUddZvchRSH5pSSKPEHlgb3CSGIdpL"
    }
    "userId": "842e2d82-7e71-4040-8eb9-d977fe888807",
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "createDate": "2014-10-09T15:54:48Z",
    "bindDate": "2014-10-09T15:56:43Z",
    "expirationDate": "2014-10-10T15:56:43Z",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094"
  }]
})
</pre>
<p id="rfc.section.4.7.7.p.19">If successful, the KMS response to a retrieve bound keys request MUST have a status of 200.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.</p>
<h1 id="rfc.section.4.7.8">
<a href="#rfc.section.4.7.8">4.7.8.</a> <a href="#create-authorizations" id="create-authorizations">Create Authorizations</a>
</h1>
<p id="rfc.section.4.7.8.p.1">An authorization establishes a relationship between a resource and a user that entitles the user to retrieve bound keys from, and bind new keys to, that resource.  The KMS resource authorization model is viral in the sense that, once a user has been authorized on a resource, that user is also entitled to authorize other users on that resource.  These authorizations are created through create authorization requests.</p>
<p id="rfc.section.4.7.8.p.2">The request message conforms to the basic request message structure, where the method is &#8220;create&#8221;, and the uri is &#8220;/authorizations&#8221;.  Additional attributes are required to indicate the resource on which authorizations are to be added, as well as the set of users for whom these new authorizations are to be created, also the number of anonymous authorization to be created.</p>
<pre>
root {
  request,
  "resourceUri" : kmsUri,
  "authIds" : [ *string ],
  "anonymous" : int
}
</pre>
<p id="rfc.section.4.7.8.p.3">Request message example:</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "create",
  "uri": "/authorizations",
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094",
  "authIds": [
    "119a0582-2e2b-4c0c-ba6a-753d05171803",
    "557ac05d-5751-43b4-a04b-e7eb1499ee0a"
  ],
  "anonymous": 1
})
</pre>
<p id="rfc.section.4.7.8.p.4">The response message conforms to the basic response message structure, and includes a representation of the set of KMS authorization objects created by the request.</p>
<p id="rfc.section.4.7.8.p.5">Response payload definition:</p>
<pre>
root {
  response,
  authorizations
}
</pre>
<p id="rfc.section.4.7.8.p.6">Response message example:</p>
<pre>
JWE(K_ephemeral, {
{
  "status": 201,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "authorizations": [
  {
    "uri": "/authorizations/79a39ed9-a8e5-4d1f-9ae2-e27857fc5901",
    "authId": "119a0582-2e2b-4c0c-ba6a-753d05171803",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094"
  },
  {
    "uri": "/authorizations/5aaca3eb-ca4c-47c9-b8e2-b20f47568b7b",
    "authId": "557ac05d-5751-43b4-a04b-e7eb1499ee0a",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094"
  },
  {
    "uri": "/authorizations/5aaca3eb-ca4c-47c9-b8e2-b20f47568b7b",
    "bearer": "EYHHBGGE2YWYtMGE2NC0...",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094"
  }]
})
</pre>
<p id="rfc.section.4.7.8.p.7">If successful, the KMS response to a create authorizations request MUST have a status of 201.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.  If for any reason one or more requested authorizations cannot be created or applied to the resource object, the entire create authorizations request MUST be failed by the KMS.</p>
<h1 id="rfc.section.4.7.9">
<a href="#rfc.section.4.7.9">4.7.9.</a> <a href="#retrieve-authorizations" id="retrieve-authorizations">Retrieve Authorizations</a>
</h1>
<p id="rfc.section.4.7.9.p.1">A client may explicitly request the set of all authorizations on a given KMS resource object.  The uri of the request is that of the resource concatenated with &#8220;/authorizations&#8221;.  The KMS MUST reject the request if the request originates from a user for which there does not exist a corresponding authorization on the resource.</p>
<p id="rfc.section.4.7.9.p.2">Request payload definition:</p>
<pre>
root {
  request
}
</pre>
<p id="rfc.section.4.7.9.p.3">Request message example:</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "retrieve",
  "uri": "/resources/7f35c3eb-95d6-4558-1942e5f03094/authorizations",
  "requestId": "913d7ae3-8945-46ca-8ed1-2b287c1370ce"
})
</pre>
<p id="rfc.section.4.7.9.p.4">The response message conforms to the basic response message structure and includes an array of KMS authorization object representations.</p>
<p id="rfc.section.4.7.9.p.5">Response payload definition:</p>
<pre>
root {
  response,
  authorizations
}
</pre>
<p id="rfc.section.4.7.9.p.6">Response message example:</p>
<pre>
JWE(K_ephemeral, {
{
  "status": 200,
  "requestId": "913d7ae3-8945-46ca-8ed1-2b287c1370ce",
  "authorizations": [
  {
    "uri": "/authorizations/79a39ed9-a8e5-4d1f-9ae2-e27857fc5901",
    "authId": "119a0582-2e2b-4c0c-ba6a-753d05171803",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-1942e5f03094"
  },
  {
    "uri": "/authorizations/5aaca3eb-ca4c-47c9-b8e2-b20f47568b7b",
    "authId": "557ac05d-5751-43b4-a04b-e7eb1499ee0a",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-1942e5f03094"
  }]
})
</pre>
<p id="rfc.section.4.7.9.p.7">If successful, the KMS response to a retrieve bound keys request MUST have a status of 200.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.</p>
<h1 id="rfc.section.4.7.10">
<a href="#rfc.section.4.7.10">4.7.10.</a> <a href="#retrieve-authorizations-by-user" id="retrieve-authorizations-by-user">Retrieve Authorizations By User</a>
</h1>
<p id="rfc.section.4.7.10.p.1">To query an authorization for the specific user from a KMS resource object, any user currently authorized on the same resource object may issue retrieve authorization request for the specific user. The request message conforms to the basic request message structure, where the method is &#8220;retrieve&#8221;, and the URI is &#8220;/authorizations&#8221; followed by authorization id.</p>
<p id="rfc.section.4.7.10.p.2">Request payload definition:</p>
<pre>
root {
  request
}
</pre>
<p id="rfc.section.4.7.10.p.3">Request message example:</p>
<pre>
JWE(K_ephemeral, {
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "retrieve",
  "uri": "/resources/a8c3c42f-5348-4289-83f0-d833d31ba93c/authorizations?authId=119a0582-2e2b-4c0c-ba6a-753d05171803",
  "requestId": "d4a741cd-0e16-4ff8-9a61-4a4b841d9e93"
})
</pre>
<p id="rfc.section.4.7.10.p.4">If successful, the KMS response to a retrieve authorization for the specific user request MUST have a status of 200.  The response message conforms to the basic response message structure and includes an array of KMS authorization object representations. The array will be empty if the specified user is not authorized for the KMS resource object. The array will contain one single authorization entry for the specified user if that user is authorized for the KMS resource object.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.</p>
<p id="rfc.section.4.7.10.p.5">Response payload definition:</p>
<pre>
root {
  response,
  authorizations
}
</pre>
<p id="rfc.section.4.7.10.p.6">Response message example:</p>
<pre>
JWE(K_ephemeral, {
{
  "status": 200,
  "requestId": "d4a741cd-0e16-4ff8-9a61-4a4b841d9e93",
  "authorizations": [
  {
    "uri": "/authorizations/ef0a5291-49cb-413f-832b-b437bc542825",
    "authId": "119a0582-2e2b-4c0c-ba6a-753d05171803",
    "resourceUri": "/resources/a8c3c42f-5348-4289-83f0-d833d31ba93c"
  }]
})
</pre>
<h1 id="rfc.section.4.7.11">
<a href="#rfc.section.4.7.11">4.7.11.</a> <a href="#delete-authorization" id="delete-authorization">Delete Authorization</a>
</h1>
<p id="rfc.section.4.7.11.p.1">To remove an authorization from a KMS resource object, any user currently authorized on the same resource object may issue a delete authorization request.  The request message conforms to the basic request message structure, where the method is &#8220;delete&#8221;, and the URI is either that of the authorization object to be deleted, or the URI of the collection of authorizations within a particular KMS resource object appended with an authId query parameter whose value matches that of the authorization object to be deleted.</p>
<p id="rfc.section.4.7.11.p.2">Request payload definition:</p>
<pre>
root {
  request
}
</pre>
<p id="rfc.section.4.7.11.p.3">Request message example, explicitly identifying the URI of the authorization object to be deleted:</p>
<pre>
JWE(K_ephemeral, {
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "delete",
  "uri": "/authorizations/5aaca3eb-ca4c-47c9-b8e2-b20f47568b7b"
})
</pre>
<p id="rfc.section.4.7.11.p.4">Request message example, implicitly identifying the authorization object to be deleted by the KMS resource object to which it belongs plus the value of its authId attribute:</p>
<pre>
JWE(K_ephemeral, {
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "delete",
  "uri": "/resources/7f35c3eb-95d6-4558-1942e5f03094
         /authorizations?authId=557ac05d-5751-43b4-a04b-e7eb1499ee0a",
})
</pre>
<p id="rfc.section.4.7.11.p.5">Note, in the example above, the URI attribute value is a continuous string of non-whitespace characters. Whitespace has been added here for readability.</p>
<p id="rfc.section.4.7.11.p.6">The response message conforms to the basic response message structure, and includes a representation of the authorization object that was deleted.</p>
<p id="rfc.section.4.7.11.p.7">Response payload definition:</p>
<pre>
root {
  response,
  ?authorization
}
</pre>
<p id="rfc.section.4.7.11.p.8">Response message example:</p>
<pre>
JWE(K_ephemeral, {
{
  "status": 200,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "authorization": {
    "uri": "/authorizations/5aaca3eb-ca4c-47c9-b8e2-b20f47568b7b",
    "authId": "557ac05d-5751-43b4-a04b-e7eb1499ee0a",
    "resourceUri": "/resources/7f35c3eb-95d6-4558-a7fc-1942e5f03094"
  }
})
</pre>
<p id="rfc.section.4.7.11.p.9">If successful, the KMS response to a delete authorization request MUST have a status of 200 if the authorization object representation is included, and 204 if not.  In the case of a request failure, the KMS response status SHOULD be that of an <a href="#RFC7231" class="xref">[RFC7231]</a> defined status code with semantics that correspond to the failure condition.</p>
<h1 id="rfc.section.4.7.12">
<a href="#rfc.section.4.7.12">4.7.12.</a> <a href="#ping" id="ping">Ping</a>
</h1>
<p id="rfc.section.4.7.12.p.1">Ping is a simple request intended to provide an efficient means for verifying the integrity of the secure channel between client and KMS.  Ping MUST be implemented as a safe and idempotent operation that causes the server to do nothing more than return a basic response payload in reaction to the client request.  The method of a ping request is &#8220;update&#8221; and the uri is &#8220;/ping&#8221;.</p>
<p id="rfc.section.4.7.12.p.2">Request payload definition:</p>
<pre>
root {
  request
}
</pre>
<p id="rfc.section.4.7.12.p.3">Request message example:</p>
<pre>
JWE(K_ephemeral, {
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
  "client": {
    "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
    "credential": {
      "bearer": "ZWU5NGE2YWYtMGE2NC0..."
    }
  }  
  "method": "update",
  "uri": "/ping"
})
</pre>
<p id="rfc.section.4.7.12.p.4">The response message conforms to the basic response message structure with no additional data.</p>
<p id="rfc.section.4.7.12.p.5">Response payload definition:</p>
<pre>
root {
  response
}
</pre>
<p id="rfc.section.4.7.12.p.6">Response message example:</p>
<pre>
JWE(K_ephemeral, {
{
  "status": 200,
  "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5"
})
</pre>
<p id="rfc.section.4.7.12.p.7">If successful, the client may deduce that the KMS was able to successfully decrypt the received KMS request message, parse the contents, confirm the identity and authorization of the requesting client, and return a suitable response.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#mandatory-to-implement" id="mandatory-to-implement">Mandatory-to-Implement</a>
</h1>
<p id="rfc.section.5.p.1">Implementations MUST support the following JWK key types from <a href="#I-D.ietf-jose-json-web-algorithms" class="xref">[I-D.ietf-jose-json-web-algorithms]</a>:</p>
<p></p>

<ul>
<li>&#8220;RSA&#8221; for the KMS static public/private key</li>
<li>&#8220;EC&#8221; for the Ephemeral Diffie Hellman exchange</li>
<li>&#8220;oct&#8221; for all symmetric keys</li>
</ul>
<p id="rfc.section.5.p.3">Implementations MUST support &#8220;PS256&#8221; (RSASSA-PSS using SHA-256 and MGF1 with SHA-256) from <a href="#I-D.ietf-jose-json-web-algorithms" class="xref">[I-D.ietf-jose-json-web-algorithms]</a> for signatures using the KMS static public/private key for <a href="#proto-ecdhe" class="xref">Section 4.7.1</a>.</p>
<p id="rfc.section.5.p.4">Implementations MUST support JWK Elliptic Curve type &#8220;P-256&#8221; (NIST P-256 curve) from <a href="#I-D.ietf-jose-json-web-algorithms" class="xref">[I-D.ietf-jose-json-web-algorithms]</a> for <a href="#proto-ecdhe" class="xref">Section 4.7.1</a>.</p>
<p id="rfc.section.5.p.5">Implementations MUST support &#8220;RSA-OAEP&#8221; (RSAES OAEP using default parameters) from <a href="#I-D.ietf-jose-json-web-algorithms" class="xref">[I-D.ietf-jose-json-web-algorithms]</a> for key encryption using the KMS static public/private key for <a href="#proto-ecdhe" class="xref">Section 4.7.1</a>.</p>
<p id="rfc.section.5.p.6">Implementations MUST support &#8220;dir&#8221; (Direct Key Agreement Key Management Mode) from <a href="#I-D.ietf-jose-json-web-algorithms" class="xref">[I-D.ietf-jose-json-web-algorithms]</a> for all operations other than <a href="#proto-ecdhe" class="xref">Section 4.7.1</a>.</p>
<p id="rfc.section.5.p.7">Implementations MUST support &#8220;A256GCM&#8221; (AES GCM using 256 bit key) from <a href="#I-D.ietf-jose-json-web-algorithms" class="xref">[I-D.ietf-jose-json-web-algorithms]</a> for content encryption for all operations other than <a href="#proto-ecdhe" class="xref">Section 4.7.1</a>.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#security-considerations" id="security-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.6.p.1">Security considerations are discussed throughout this document.  Additional considerations may be added here as needed.</p>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#appendix-a-acknowledgments" id="appendix-a-acknowledgments">Appendix A. Acknowledgments</a>
</h1>
<p id="rfc.section.7.p.1">This specification is the work of several contributors.  In particular, the following individuals contributed ideas, feedback, and wording that influenced this specification:</p>
<p id="rfc.section.7.p.2">Cullen Jennings, Matt Miller, Suhas Nandakumar, Jonathan Rosenberg, Bo Zou</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#appendix-b-document-history" id="appendix-b-document-history">Appendix B. Document History</a>
</h1>
<p id="rfc.section.8.p.1">-00</p>
<p></p>

<ul><li>Initial draft.</li></ul>
<h1 id="rfc.references">
<a href="#rfc.references">9.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">9.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.ietf-jose-json-web-algorithms">[I-D.ietf-jose-json-web-algorithms]</b></td>
<td class="top">
<a>Jones, M.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-algorithms-40">JSON Web Algorithms (JWA)</a>", Internet-Draft draft-ietf-jose-json-web-algorithms-40, January 2015.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-jose-json-web-encryption">[I-D.ietf-jose-json-web-encryption]</b></td>
<td class="top">
<a>Jones, M.</a> and <a>J. Hildebrand</a>, "<a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-encryption-40">JSON Web Encryption (JWE)</a>", Internet-Draft draft-ietf-jose-json-web-encryption-40, January 2015.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-jose-json-web-key">[I-D.ietf-jose-json-web-key]</b></td>
<td class="top">
<a>Jones, M.</a>, "<a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-key-41">JSON Web Key (JWK)</a>", Internet-Draft draft-ietf-jose-json-web-key-41, January 2015.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-jose-json-web-signature">[I-D.ietf-jose-json-web-signature]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/draft-ietf-jose-json-web-signature-41">JSON Web Signature (JWS)</a>", Internet-Draft draft-ietf-jose-json-web-signature-41, January 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC2822">[RFC2822]</b></td>
<td class="top">
<a>Resnick, P.</a>, "<a href="https://tools.ietf.org/html/rfc2822">Internet Message Format</a>", RFC 2822, DOI 10.17487/RFC2822, April 2001.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3339">[RFC3339]</b></td>
<td class="top">
<a>Klyne, G.</a> and <a>C. Newman</a>, "<a href="https://tools.ietf.org/html/rfc3339">Date and Time on the Internet: Timestamps</a>", RFC 3339, DOI 10.17487/RFC3339, July 2002.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4949">[RFC4949]</b></td>
<td class="top">
<a>Shirey, R.</a>, "<a href="https://tools.ietf.org/html/rfc4949">Internet Security Glossary, Version 2</a>", FYI 36, RFC 4949, DOI 10.17487/RFC4949, August 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5280">[RFC5280]</b></td>
<td class="top">
<a>Cooper, D.</a>, <a>Santesson, S.</a>, <a>Farrell, S.</a>, <a>Boeyen, S.</a>, <a>Housley, R.</a> and <a>W. Polk</a>, "<a href="https://tools.ietf.org/html/rfc5280">Internet X.509 Public Key Infrastructure Certificate and Certificate Revocation List (CRL) Profile</a>", RFC 5280, DOI 10.17487/RFC5280, May 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5869">[RFC5869]</b></td>
<td class="top">
<a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="https://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6120">[RFC6120]</b></td>
<td class="top">
<a>Saint-Andre, P.</a>, "<a href="https://tools.ietf.org/html/rfc6120">Extensible Messaging and Presence Protocol (XMPP): Core</a>", RFC 6120, DOI 10.17487/RFC6120, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6125">[RFC6125]</b></td>
<td class="top">
<a>Saint-Andre, P.</a> and <a>J. Hodges</a>, "<a href="https://tools.ietf.org/html/rfc6125">Representation and Verification of Domain-Based Application Service Identity within Internet Public Key Infrastructure Using X.509 (PKIX) Certificates in the Context of Transport Layer Security (TLS)</a>", RFC 6125, DOI 10.17487/RFC6125, March 2011.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6749">[RFC6749]</b></td>
<td class="top">
<a>Hardt, D.</a>, "<a href="https://tools.ietf.org/html/rfc6749">The OAuth 2.0 Authorization Framework</a>", RFC 6749, DOI 10.17487/RFC6749, October 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7159">[RFC7159]</b></td>
<td class="top">
<a>Bray, T.</a>, "<a href="https://tools.ietf.org/html/rfc7159">The JavaScript Object Notation (JSON) Data Interchange Format</a>", RFC 7159, DOI 10.17487/RFC7159, March 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7231">[RFC7231]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">9.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.barnes-pervasive-problem">[I-D.barnes-pervasive-problem]</b></td>
<td class="top">
<a>Barnes, R.</a>, <a>Schneier, B.</a>, <a>Jennings, C.</a> and <a>T. Hardie</a>, "<a href="https://tools.ietf.org/html/draft-barnes-pervasive-problem-01">Pervasive Attack: A Threat Model and Problem Statement</a>", Internet-Draft draft-barnes-pervasive-problem-01, July 2014.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-xmpp-posh">[I-D.ietf-xmpp-posh]</b></td>
<td class="top">
<a>Miller, M.</a> and <a>P. Saint-Andre</a>, "<a href="https://tools.ietf.org/html/draft-ietf-xmpp-posh-06">PKIX over Secure HTTP (POSH)</a>", Internet-Draft draft-ietf-xmpp-posh-06, September 2015.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.newton-json-content-rules">[I-D.newton-json-content-rules]</b></td>
<td class="top">
<a>Newton, A.</a> and <a>P. Cordell</a>, "<a href="https://tools.ietf.org/html/draft-newton-json-content-rules-09">A Language for Rules Describing JSON Content</a>", Internet-Draft draft-newton-json-content-rules-09, September 2017.</td>
</tr>
<tr>
<td class="reference"><b id="OTR">[OTR]</b></td>
<td class="top">
<a>Borisov, N.</a>, <a>Goldberg, I.</a> and <a>E. Brewer</a>, "<a href="https://otr.cypherpunks.ca/otr-wpes.pdf">Off-the-Record Communication, or, Why Not To Use PGP</a>", 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4301">[RFC4301]</b></td>
<td class="top">
<a>Kent, S.</a> and <a>K. Seo</a>, "<a href="https://tools.ietf.org/html/rfc4301">Security Architecture for the Internet Protocol</a>", RFC 4301, DOI 10.17487/RFC4301, December 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4880">[RFC4880]</b></td>
<td class="top">
<a>Callas, J.</a>, <a>Donnerhacke, L.</a>, <a>Finney, H.</a>, <a>Shaw, D.</a> and <a>R. Thayer</a>, "<a href="https://tools.ietf.org/html/rfc4880">OpenPGP Message Format</a>", RFC 4880, DOI 10.17487/RFC4880, November 2007.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5246">[RFC5246]</b></td>
<td class="top">
<a>Dierks, T.</a> and <a>E. Rescorla</a>, "<a href="https://tools.ietf.org/html/rfc5246">The Transport Layer Security (TLS) Protocol Version 1.2</a>", RFC 5246, DOI 10.17487/RFC5246, August 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5652">[RFC5652]</b></td>
<td class="top">
<a>Housley, R.</a>, "<a href="https://tools.ietf.org/html/rfc5652">Cryptographic Message Syntax (CMS)</a>", STD 70, RFC 5652, DOI 10.17487/RFC5652, September 2009.</td>
</tr>
</tbody></table>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Andrew Biggs</span> 
	  <span class="n hidden">
		<span class="family-name">Biggs</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:adb@cisco.com">adb@cisco.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Shaun Cooley</span> 
	  <span class="n hidden">
		<span class="family-name">Cooley</span>
	  </span>
	</span>
	<span class="org vcardline">Cisco Systems</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:shcooley@cisco.com">shcooley@cisco.com</a></span>

  </address>
</div>

</body>
</html>
