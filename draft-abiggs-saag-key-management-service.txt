



Network Working Group                                           A. Biggs
Internet-Draft                                                 S. Cooley
Intended status: Standards Track                           Cisco Systems
Expires: January 4, 2016                                   July 03, 2015


                  Key Management Service Architecture
              draft-abiggs-saag-key-management-service-02

Abstract

   In the interest of addressing pervasive threats to the
   confidentiality and integrity of online communications identified by
   the Internet community [I-D.barnes-pervasive-problem] this
   specification introduces an open architecture for the establishment,
   management, and secure distribution of cryptographic keys for use in
   the end-to-end (E2E) encryption of online communications and shared
   content.  This architecture allows for the independent deployment of
   dedicated key management services in a manner that supports the
   adoption of third-party communications and data sharing services by
   individuals and organizations that require full and exclusive
   discretion over the confidentiality of their data.

Status of This Memo

   This Internet-Draft is submitted in full conformance with the
   provisions of BCP 78 and BCP 79.

   Internet-Drafts are working documents of the Internet Engineering
   Task Force (IETF).  Note that other groups may also distribute
   working documents as Internet-Drafts.  The list of current Internet-
   Drafts is at http://datatracker.ietf.org/drafts/current/.

   Internet-Drafts are draft documents valid for a maximum of six months
   and may be updated, replaced, or obsoleted by other documents at any
   time.  It is inappropriate to use Internet-Drafts as reference
   material or to cite them other than as "work in progress."

   This Internet-Draft will expire on January 4, 2016.

Copyright Notice

   Copyright (c) 2015 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (http://trustee.ietf.org/license-info) in effect on the date of



Biggs & Cooley           Expires January 4, 2016                [Page 1]

Internet-Draft           key-management-service                July 2015


   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction  . . . . . . . . . . . . . . . . . . . . . . . .   3
     1.1.  Terminology . . . . . . . . . . . . . . . . . . . . . . .   4
     1.2.  Security Terms  . . . . . . . . . . . . . . . . . . . . .   5
     1.3.  Notational Conventions  . . . . . . . . . . . . . . . . .   6
   2.  Architectural Overview  . . . . . . . . . . . . . . . . . . .   6
   3.  Use Cases . . . . . . . . . . . . . . . . . . . . . . . . . .   8
     3.1.  Securing an HTTP File Sharing Service . . . . . . . . . .   9
     3.2.  Securing an XMPP Multi-User Chat  . . . . . . . . . . . .  11
     3.3.  KMS to KMS Key Federation . . . . . . . . . . . . . . . .  13
   4.  KMS Protocol  . . . . . . . . . . . . . . . . . . . . . . . .  16
     4.1.  Secure Channel  . . . . . . . . . . . . . . . . . . . . .  16
     4.2.  User Identity . . . . . . . . . . . . . . . . . . . . . .  17
     4.3.  KMS Identity  . . . . . . . . . . . . . . . . . . . . . .  17
     4.4.  Object Types  . . . . . . . . . . . . . . . . . . . . . .  18
     4.5.  Message Structure . . . . . . . . . . . . . . . . . . . .  18
       4.5.1.  Basic Request Payload . . . . . . . . . . . . . . . .  19
       4.5.2.  Basic Response Payload  . . . . . . . . . . . . . . .  21
       4.5.3.  Error Response Payload  . . . . . . . . . . . . . . .  22
     4.6.  Requests  . . . . . . . . . . . . . . . . . . . . . . . .  22
       4.6.1.  Create Ephemeral Key  . . . . . . . . . . . . . . . .  22
       4.6.2.  Delete Ephemeral Key  . . . . . . . . . . . . . . . .  25
       4.6.3.  Post GMBC Genesis Block . . . . . . . . . . . . . . .  26
       4.6.4.  Post GMBC Block . . . . . . . . . . . . . . . . . . .  28
       4.6.5.  Get GMBC  . . . . . . . . . . . . . . . . . . . . . .  30
       4.6.6.  Create GK . . . . . . . . . . . . . . . . . . . . . .  32
       4.6.7.  Post GK . . . . . . . . . . . . . . . . . . . . . . .  33
       4.6.8.  Retrieve GK . . . . . . . . . . . . . . . . . . . . .  34
       4.6.9.  Ping  . . . . . . . . . . . . . . . . . . . . . . . .  35
   5.  Mandatory-to-Implement  . . . . . . . . . . . . . . . . . . .  36
   6.  Security Considerations . . . . . . . . . . . . . . . . . . .  37
   7.  Appendix A. Acknowledgments . . . . . . . . . . . . . . . . .  37
   8.  Appendix B. Document History  . . . . . . . . . . . . . . . .  37
   9.  References  . . . . . . . . . . . . . . . . . . . . . . . . .  37
     9.1.  Normative References  . . . . . . . . . . . . . . . . . .  37
     9.2.  Informative References  . . . . . . . . . . . . . . . . .  38
   Authors' Addresses  . . . . . . . . . . . . . . . . . . . . . . .  39






Biggs & Cooley           Expires January 4, 2016                [Page 2]

Internet-Draft           key-management-service                July 2015


1.  Introduction

   Providers of cloud-based services commonly secure user data at the
   transport level using established protocols such as TLS [RFC5246] or
   IPSec [RFC4301].  These protocols can be effective in protecting
   transmitted user data from third party tampering and eavesdropping;
   however, by themselves these protocols do not secure user data from
   abuses, negligence, or coerced behavior on the part of the cloud
   provider.  This is a concern for individuals and organizations that
   wish to take advantage of cloud-based communications and
   collaboration but cannot accept the risk of trusting cloud providers
   with unfettered access to the contents of their communications.

   E2E encryption describes a category of solutions that can be employed
   to address this problem by establishing secure channels among
   clients.  To the extent that a user can trust their collaboration
   client software, E2E encryption mitigates exposure of user data to
   untrusted parties by ensuring that intermediaries never possess
   unencrypted user data or have access to the keying material necessary
   to decrypt it.

   Existing E2E strategies such as ECS [RFC5652], PGP [RFC4880], and
   Off-the-Record Messaging [OTR] can be effective at securing two-party
   communications.  However, E2E encryption for the growing domain of
   multiparty communications and online content sharing remains a
   generally unsolved problem to which these existing approaches do not
   readily adapt.  In particular, a core challenge exists in providing
   for the secure distribution and rotation of E2E encryption keys among
   an arbitrary and potentially dynamic set of communicating clients.
   In cases where the communications to be secured are persistent or
   archived, the additional challenge exists for providing trusted long-
   term storage and retrieval of these keys.

   Equally problematic is the paucity of E2E encryption options that
   satisfy common organizational obligations such as regulatory
   compliance and legal discovery.  Entities that must operate within
   such frameworks require mechanisms by which they (and they alone) may
   recover the keys used to secure their communications.  Existing E2E
   encryption solutions are not, by themselves, well suited for this
   purpose.

   In the interest of addressing these challenges, this document
   presents an architecture for the deployment of E2E encryption key
   management services (KMS) that fulfills the curator role described in
   [I-D.abiggs-saag-primitives-for-conf-group-comms].

   In the interest of addressing these challenges this document presents
   an architecture for the deployment of E2E encryption key management



Biggs & Cooley           Expires January 4, 2016                [Page 3]

Internet-Draft           key-management-service                July 2015


   services (KMS).  In this architecture a KMS service provides to its
   users a means by which their communications clients may securely
   create, share, rotate, and store E2E encryption keying material.  It
   does so in a fashion that permits the decoupling of such services
   from the communications media, thereby permitting the former to
   reside under the direct control of the communicating parties or the
   organizations within which they do business.

1.1.  Terminology

   This document uses the terminology from
   [I-D.ietf-jose-json-web-signature],
   [I-D.ietf-jose-json-web-encryption], [I-D.ietf-jose-json-web-key],
   and [I-D.ietf-jose-json-web-algorithms] when discussing JOSE
   technologies.

   This document uses the terminology from
   [I-D.abiggs-saag-primitives-for-conf-group-comms] when discussing
   authentication, group membership, and secure key exchange.

   This document makes use of the following terminology, and
   additionally adopts nomenclature defined in
   [I-D.barnes-pervasive-problem] for the purpose of describing aspects
   of pervasive attacks.

   communications resource

      A communications resource is any uniquely identifiable continuous
      data channel or discrete shared content that represents an
      exchange of personal communications between two or more users.

   communications resource client

      A communications resource client consumes communications resources
      on behalf of a user and, when deployed in conformance with the KMS
      architecture, consumes the services of KMS server(s) to facilitate
      the E2E encryption of those communications resources.

   communications resource server

      A communications resource server is a provider of services through
      which communications resources are made available.

   cloud provider

      An individual or organization responsible for, and in control of,
      one or more communications resource servers.




Biggs & Cooley           Expires January 4, 2016                [Page 4]

Internet-Draft           key-management-service                July 2015


   E2E encryption

      Shorthand for end-to-end encryption, as defined in [RFC4949],
      particularly as it applies to the establishment of confidentiality
      and integrity of communications resources.

   KMS server

      A key management server (KMS) is responsible for creating,
      storing, and providing access to E2E encryption keying material by
      communications resource clients.

   KMS protocol

      The protocol through which communications resource clients
      interoperate with KMS servers.

   KMS provider

      An individual or organization responsible for, and in control of,
      a KMS server deployment.

   KMS transport

      Any service or protocol that provides the basic transport over
      which KMS protocol messages are exchanged.

   resource client

      See communications resource client.

   resource server

      See communications resource server.

   trusted party

      A trusted party is an individual or organization that is trusted
      by one or more communicating users to maintain the confidentiality
      and integrity of their communications resources.

1.2.  Security Terms

   Most security-related terms in this document are to be understood in
   the sense defined in [RFC4949]; such terms include, but are not
   limited to, "attack", "authentication", "authorization",
   "certification authority", "certification path", "certificate",




Biggs & Cooley           Expires January 4, 2016                [Page 5]

Internet-Draft           key-management-service                July 2015


   "credential", "identity", "self-signed certificate", "trust", "trust
   anchor", "trust chain", "validate", and "verify".

1.3.  Notational Conventions

   In this document, the key words "MUST", "MUST NOT", "REQUIRED",
   "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY",
   and "OPTIONAL" are to be interpreted as described in BCP 14, RFC 2119
   [RFC2119].

2.  Architectural Overview

   The architectural reference model for this specification is
   illustrated in Figure 1.  Central to this model is the
   _communications resource server_ which is presumed to be operated by
   a _cloud provider_ for the purpose of offering some form of
   communications service.  The nature of this service is not prescribed
   by this specification and may take the form of any of a variety of
   communications or collaboration services including file sharing,
   messaging, and VoIP.  Consuming the services of the communications
   resource server are _communications resource clients_ which may be
   supplied by the cloud provider or developed by third parties.

                            +-----------------+
                            | Communications  |
        +-------------------| Resource Server |-------------------+
        |                   | (Cloud Provider)|                   |
        |                   +-----------------+                   |
        |                                                         |
        |                                                         |
        |                   +-----------------+                   |
        |       +-----------|  KMS Transport  |-----------+       |
        |       |           +-----------------+           |       |
        |       |                    |                    |       |
        |       |   Untrusted        |                    |       |
   - - -|- - - -|- - - - - - - - - - | - - - - - - - - - -|- - - -|- - -
        |       |   Trusted          |                    |       |
        |       |                    |                    |       |
   +-----------------+      +-----------------+      +-----------------+
   | Communications  |      |    KMS Server   |      | Communications  |
   | Resource Client |      |  (KMS Provider) |      | Resource Client |
   +-----------------+      +-----------------+      +-----------------+
            |                                                 |
   +-----------------+                               +-----------------+
   |      Alice      |                               |       Bob       |
   +-----------------+                               +-----------------+

                Figure 1: KMS Architecture Reference Model



Biggs & Cooley           Expires January 4, 2016                [Page 6]

Internet-Draft           key-management-service                July 2015


   In addition to the familiar elements described above, this model also
   includes a key management server, or _KMS_, operated by a _KMS
   provider_. The KMS server exposes an API through which clients may
   securely post and share cryptographic keying material used for the
   E2E encryption of content that is transited through the cloud
   provider's services.  The API exposed by the KMS implements the
   curator functions described in the Centralized Groups section of
   [I-D.abiggs-saag-primitives-for-conf-group-comms].  It is important
   to note that the KMS is a dedicated curator rather than a content
   producing curator.  This API is secured in such a way as to ensure
   these keys are visible to none but the KMS server itself and the
   clients authorized to consume the content they protect.  This
   highlights an important distinction between the KMS provider and the
   cloud provider: while the KMS provider is necessarily a _trusted
   party_, the cloud provider need not be.

   It is an explicit objective of this specification to promote an
   ecosystem of providers of KMS implementations and KMS services that
   are distinct and independent of the cloud providers over whose
   services users communicate.  To that end, this specification seeks to
   standardize a KMS service protocol though which clients and KMS
   servers interoperate.  This protocol provides for the establishment
   of a confidential and authenticated channel between each client and
   KMS server, and defines an API of request and response messages to be
   exchanged over this secure channel for the purpose of creating,
   retrieving, and exchanging keys.

   While the KMS service protocol constitutes a central focus of this
   specification, the means by which this protocol is transported is
   expressly out of scope.  This role may be readily addressed through
   either standards-based or proprietary protocols, and so we refer to
   this simply as the _KMS transport_ for the remainder of this
   document.  Over this transport, the communication paths between
   clients and KMS server are encrypted using keys established through
   an authenticated ephemeral key agreement.  As such, the KMS transport
   provider need not be regarded as a trusted party, and in fact may be
   the cloud provider itself.

   An important non-goal of this specification is the standardization of
   any aspect of the cloud provider's services or the means by which
   clients utilize shared keys for the E2E encryption of data transiting
   those services.  By avoiding the application of constraints on the
   communications services and protocols we enable the use of this
   specification in the context of existing service deployments, both
   standards-based and proprietary.  It is similarly a non-goal of this
   specification to enable federation of secure communications between
   vendors of different cloud services, as that is the realm of
   standardized application protocols.  The scope of this specification



Biggs & Cooley           Expires January 4, 2016                [Page 7]

Internet-Draft           key-management-service                July 2015


   is intended to be narrowly focused on the task of separating E2E
   encryption key management from the communications services they
   secure, thereby facilitating the broadest possible adoption of secure
   communications though existing services.

3.  Use Cases

   The use cases described in this section are non-normative examples
   meant to illustrate how the KMS architecture may be deployed to
   provide E2E encryption of different types of communications
   resources.  These use cases differ in detail, but generally follow a
   common logical sequence as given below.

   Note that all requests to the KMS server are via the KMS transport
   which, for clarity, has been omitted from the sequence diagrams
   included in this section.

      Resource          Resource          Resource            KMS
      Client B          Client A           Server            Server
         |                 |                 |       (1)       |
         |                 |-----------------|---------------->|
         |                 |                 |       (2)       |
         |                 |-----------------|---------------->|
         |                 |                 |                 |
         |             (3) |                 |                 |
         |                 |       (4)       |                 |
         |                 |---------------->|                 |
         |                 |                 |       (5)       |
         |                 |-----------------|---------------->|
         |                 |                 |       (6)       |
         |                 |-----------------|---------------->|
         |                 |       (7)       |                 |
         |-----------------|---------------->|                 |
         |                 |                 |       (8)       |
         |-----------------|-----------------|---------------->|
         |                 |                 |                 |
     (9) |                 |                 |                 |
         |                 |                 |                 |


                        Figure 2: Nominal Use Case

   1.  Client A requests a new GMBC from the KMS server.  The KMS
       creates and returns a new genesis block with the KMS as curator
       and client A as a member.

   2.  Client A requests that the KMS generate a new GK with a null hash
       attribute.  The KMS generates the GK and returns it to the client



Biggs & Cooley           Expires January 4, 2016                [Page 8]

Internet-Draft           key-management-service                July 2015


       with client A as the only recipient of the embedded JWE used to
       wrap the included key material.

   3.  Client A encrypts a resource using the key material protected by
       the GK.

   4.  Client A posts the encrypted resource to the resource server,
       including the URI of the GK as metadata.

   5.  Client A creates and signs a new GMBC block containing an
       operation to add client B and using the hash of the genesis block
       from step 1 as the antecedent.  Client A posts this block to the
       KMS for appending to the GMBC.

   6.  Client A posts a request to the KMS to alter the hash attribute
       of the GK from 2 to now be the hash of the GMBC block posted in 5
       (this has the effect of linking authorization for retrieval of
       the GK to the membership of the GMBC at that particular block).

   7.  Client B obtains the encrypted resource from the resource server,
       including the GK URI as metadata.

   8.  Client B performs a GK Get to obtain the GK from the KMS server.
       The KMS checks the hash on the requested GK and examines the GMBC
       block to which it refers.  The membership of the GMBC at that
       block includes client B, so the server returns the GK to the
       client with client B as the only recipient of the JWE used to
       wrap the included key material.

   9.  Client B decrypts the resource using the key material protected
       by the GK.

3.1.  Securing an HTTP File Sharing Service

   Let A be a user that wishes to share a file with users B and C
   through some HTTP based file sharing service.  In the context of the
   KMS architecture we may regard the file sharing provider's HTTP API
   as the resource server and the users' HTTP clients as the resource
   clients.

   For this scenario we also assume that the file sharing service is
   trusted by user A with the role of providing a file sharing mechanism
   but is not necessarily trusted to adequately protect the
   confidentiality of the file contents.  User A's concerns may then be
   addressed through the introduction of an HTTP based KMS transport
   (not shown) and a KMS server deployed by an entity that A regards as
   a trusted party.




Biggs & Cooley           Expires January 4, 2016                [Page 9]

Internet-Draft           key-management-service                July 2015


        HTTP           HTTP           HTTP       HTTP File         KMS
      Client C       Client B       Client A    Share Server      Server
         |              |              |              |             |
         |              |              |              |     (1)     |
         |              |              |--------------|------------>|
         |              |              |      (2)     |             |
         |              |              |------------->|             |
         |      (3)     |      (3)     |              |             |
         |<-------------|<-------------|--------------|             |
         |              |              |              |             |
         |              |          (4) |              |             |
         |              |              |              |     (5)     |
         |              |              |--------------|------------>|
         |              |              |      (6)     |             |
         |              |--------------|------------->|             |
         |              |              |              |     (7)     |
         |              |--------------|--------------|------------>|
         |              |              |              |             |
         |          (8) |              |              |             |
         |              |              |              |             |
     (9) |              |              |              |             |
         |              |              |              |             |

                      Figure 3: File Sharing Use Case

   This sequence begins with the assumption that each client has, at
   some point, already established a secure channel to the KMS via
   authenticated key agreement.

   1.  Client A reserves a unique GMBC URL and a unique GK URL from the
       KMS server.

   2.  Client A generates a GK using the reserved GK URI and containing
       a reference to the reserved GMBC URI.  Client A encrypts a file
       using the key material protected by the GK, and posts the file to
       the file sharing service, including the GK URL as metadata.  A
       file URL is returned in the response.

   3.  Clients B and C learn of the newly shared file from the file
       sharing service (the mechanism by which this occurs is out of
       scope for this specification).

   4.  Client A generates a new GMBC by creating a genesis block using
       the reserved GMBC URI.  The genesis block references the resource
       URI obtained in (3) and includes group membership "add"
       operations for each of Clients A, B, and C.  The URI of the KMS
       server is used in the curator field.




Biggs & Cooley           Expires January 4, 2016               [Page 10]

Internet-Draft           key-management-service                July 2015


   5.  Client A posts the GK and GMBC created in steps (2) and (4) to
       the KMS server.

   6.  Client B obtains the encrypted file from the file sharing
       service, including the GK URL as metadata.

   7.  Client B performs a get on the GK URL to obtain the GK from the
       KMS server.  The KMS server generates a new GK based on the
       original GK created in (2), but with Client B as the recipient.

   8.  Client B decrypts the encrypted file using the key material
       protected by the GK.

   9.  Client C performs steps (6) through (8) in the same fashion as
       client B.

   It is worth noting that a race condition does exist where step (7)
   could occur before step (5) completes.  This will result in a client
   being temporarily denied access to the key used to encrypt the shared
   file.

3.2.  Securing an XMPP Multi-User Chat

   Let A, B and C be users that wish to engage in secure chat through an
   existing XMPP multi-user chat room.  In the context of the KMS
   architecture we may regard the XMPP MUC service as the resource
   server, the users' XMPP clients as the resource clients, and the XMPP
   service itself (not shown) as the KMS transport.























Biggs & Cooley           Expires January 4, 2016               [Page 11]

Internet-Draft           key-management-service                July 2015


        XMPP           XMPP           XMPP         XMPP MUC        KMS
      Client C       Client B       Client A        Server        Server
         |              |              |              |             |
         |              |              |              |     (1)     |
         |              |              |--------------|------------>|
         |              |              |              |             |
         |              |          (2) |              |             |
         |              |              |              |             |
         |              |          (3) |              |             |
         |              |              |              |     (4)     |
         |              |              |--------------|------------>|
         |              |              |      (5)     |             |
         |              |              |------------->|             |
         |      (6)     |      (6)     |              |             |
         |<-------------|<-------------|--------------|             |
         |              |              |              |     (7)     |
         |              |--------------|--------------|------------>|
         |              |              |              |             |
         |          (8) |              |              |             |
         |              |              |              |             |
     (9) |              |              |              |             |

                    Figure 4: Multi-User Chat Use Case

   This sequence begins with the assumption that a MUC room already
   exists on the MUC server and that each client has already established
   a secure channel to the KMS via authenticated key agreement.  All
   messages are transmitted over XMPP.

   1.  Client A reserves a unique GMBC URL and a unique GK URL from the
       KMS server.

   2.  Client A generates a new GMBC by creating a genesis block using
       the reserved GMBC URI.  The genesis block references the MUC room
       JID as the resource URI, and includes group membership "add"
       operations for each member of the MUC room.  The JID of the KMS
       server is used in the curator field.

   3.  Client A generates a GK using the reserved GK URI and containing
       a reference to the GMBC URI.

   4.  Via an XMPP protocol binding, client A performs GMBC Post and GK
       Post operations to upload the GMBC and GK objects created in
       steps (2) and (3) to the KMS server.

   5.  Client A encrypts the content of an XMPP message using the key
       material from the GK created in step (3), and sends the encrypted




Biggs & Cooley           Expires January 4, 2016               [Page 12]

Internet-Draft           key-management-service                July 2015


       message to the MUC room.  The GK URI is included within the XMPP
       message as metadata.

   6.  The MUC service delivers client A's encrypted message to clients
       B and C.

   7.  Via an XMPP protocol binding, client B performs a GK Get
       operation to retrieve the GK from the KMS server using the GK URI
       included in the encrypted message's metadata.

   8.  Client B decrypts the messages using the key material protected
       by the GK.

   9.  Client C performs steps (7) and (8) in the same fashion as Client
       B.

3.3.  KMS to KMS Key Federation

   This use case illustrates two KMS instances federating keys
   associated with a resource.  As KMS servers are deployed to serve
   groups of users it is inevitable that users will want to share
   resources across groups or organizations.  This cross-organization
   sharing of keys leads to several problems.  First, each user is only
   known to and only knows of one logical KMS.  Second, each
   organization might have very different archiving requirements due to
   differing legal compliance regulations due to jurisdiction or
   industry differences.  Lastly, one or both of the users might be
   employees of enterprises that need to be able to respond to legal
   discovery requests.  To address these issues, KMS servers may
   federate in such a way as to allow for limited copying of keys from
   one KMS to another.  This permits each KMS' owning organization the
   ability to control the ongoing policy regarding access to keys for
   which their respective users are authorized.

   Let Alice@DomainA and Bob@DomainB be users of a common file sharing
   service and who happen to use different KMS servers to secure their
   communications.  Assume then that Alice wishes to share a file with
   Bob and therefore relies on KMS server federation to facilitate the
   key exchange.












Biggs & Cooley           Expires January 4, 2016               [Page 13]

Internet-Draft           key-management-service                July 2015


   HTTP Client   HTTP Client     HTTP File      KMS Server   KMS Server
   Bob@DomainB  Alice@DomainA   Share Server     DomainA       DomainB
        |             |              |      (1)     |             |
        |             |--------------|------------->|             |
        |             |      (2)     |              |             |
        |             |------------->|              |             |
        |     (3)     |              |              |             |
        |<------------|--------------|              |             |
        |         (4) |              |              |             |
        |             |              |              |             |
        |         (5) |              |              |             |
        |             |              |              |             |
        |             |              |      (6)     |             |
        |             |--------------|------------->|             |
        |             |      (7)     |              |             |
        |-------------|------------->|              |             |
        |             |              |              |     (8)     |
        |-------------|--------------|--------------|------------>|
        |             |              |              |     (9)     |
        |             |              |              |<------------|
        |             |              |              |     (10)    |
        |             |              |              |------------>|
        |             |              |              |             |
        |             |              |              |             | (11)
        |             |              |              |             |
   (12) |             |              |              |             |
        |             |              |              |             |

            Figure 5: File Sharing with KMS Federation Use Case

   This sequence begins with the assumption that each client has, at
   some point, already established a secure channel to their respective
   KMS via authenticated key agreement.

   1.   Alice@DomainA requests from the DomainA KMS some number of
        unique GMBC URLs.  Each KMS key is uniquely identified by a URL.

   2.   Alice@DomainA selects a reserved GMBC URI from the set of URIs
        obtained in step (1), generates a symmetric key, encrypts the
        file to be shared, and posts the encrypted content to the file
        sharing service.  As metadata to the file posted to the file
        sharing service, Alice@DomainA includes the GMBC URL.  The file
        sharing service responds with a URL that uniquely identifies the
        shared file.

   3.   Bob@DomainB is notified of the newly shared file URL through a
        notification from the file sharing service (or potentially some
        other means, such an an email from Alice).



Biggs & Cooley           Expires January 4, 2016               [Page 14]

Internet-Draft           key-management-service                July 2015


   4.   Alice@DomainA generates a new GMBC by creating a genesis block,
        containing the unique shared file URL, two group membership
        "add" operations (one for itself and one for Bob@DomainB), and
        the KMS' URI in the curator field.

   5.   Alice@DomainA creates a GK that includes a hash of the GMBC
        genesis block, and encrypts the key material portion of the GK
        using a JWE JSON serialization that indicates the KMS server is
        the recipient.

   6.   Alice@DomainA performs a GMBC Post and GK Post of the GMBC and
        GK created in steps 4 and 5, respectively, to the KMS Server.

   7.   Bob@DomainB retrieves the shared file from the file sharing
        service along with the GMBC URL contained in metadata.

   8.   Using the GMBC key URL obtained in step (7), Bob@DomainB
        requests the GMBC from the DomainB KMS.

   9.   The DomainB KMS recognizes the GMBC URL as actually hosted by
        the DomainA KMS.  The DomainB KMS establishes a secure and
        mutually authenticated channel with the DomainA KMS via the KMS
        transport.

   10.  The DomainB KMS requests from the DomainA KMS the GMBC and GK
        objects, along with all DomainB user authorizations.  The
        DomainA KMS recognizes that the DomainB KMS is authorized to
        retrieve all KMS keys for which users in the DomainB domain have
        been authorized.  It then recognizes that at least one DomainB
        user (Bob) has been authorized on the GMBC created in step (4).
        The DomainA KMS therefore decides the DomainB KMS is authorized
        to make this request, it adds DomainB KMS to the GMBC and
        returns the updated GMBC along with the GK encrypted for DomainB
        KMS.

   11.  Using the information received from the DomainA KMS, the DomainB
        KMS verifies that Bob@DomainB is authorized on the GMBC, and
        satisfies the request from step (8) by returning the KMS key to
        Bob@DomainB.

   12.  Bob@DomainB decrypts the shared file using the key obtained in
        step (11).

   Note that in step (11) the DomainB KMS is enforcing authorization
   policy for the GMBC hosted on the DomainA KMS as it pertains to
   DomainB users.  This is a necessary consequence of KMS federation,
   where the act of authorizing access to a GMBC by a user residing in a
   federated domain engenders an implicit trust of the KMS server that



Biggs & Cooley           Expires January 4, 2016               [Page 15]

Internet-Draft           key-management-service                July 2015


   controls the federated domain.  For that reason, a KMS provider
   should restrict federation of its KMS servers to domains that the KMS
   provider regards as trusted.

4.  KMS Protocol

   The KMS protocol is composed of a message oriented request and
   response API and a secure channel over which those messages are
   exchanged.  The API provides clients with the ability to post and
   retrieve GMBC and GK objects.  The secure channel provides a mutually
   authenticated and E2E encrypted channel over which the clients and
   KMS server may exchange API messages securely.  The API and secure
   channel are described in detail through the remainder of this
   section.

4.1.  Secure Channel

   The secure channel is an encrypted and mutually authenticated
   communication path between each client and the KMS server.  It
   transits the KMS transport which, in the context of this document,
   represents any service or protocol that may be utilized for the
   relaying of KMS API request and response messages.  This
   specification presumes the KMS transport to be untrusted.

                             (3) Secure Channel
           +===================================================+
           V                                                   V
   +-----------------+  (2)   +---------------+   (1)  +---------------+
   | Resource Client |<------>| KMS Transport |<------>|   KMS Server  |
   +-----------------+        +---------------+        +---------------+
                         |                         |
        Trusted          |        Untrusted        |        Trusted

                Figure 6: Establishment of a Secure Channel

   At a high level, the communication path between a resource client and
   KMS is established as follows.

   1.  The KMS actively connects to the KMS transport.  The protocol
       used for this connection is out of scope for this document,
       however it MUST support the asynchronous flow of encrypted KMS
       request and response messages between the KMS and KMS transport.

   2.  A resource client connects to the KMS transport.  The protocol
       used for this connection is out of scope for this document,
       however it MUST support the flow of encrypted KMS request and
       response messages between the resource client and the KMS
       transport.



Biggs & Cooley           Expires January 4, 2016               [Page 16]

Internet-Draft           key-management-service                July 2015


   3.  Through an elliptic curve Diffie-Helman key exchange, augmented
       by server and client authentication, the resource client and KMS
       establish a shared secret and derived ephemeral key.  This is
       discussed in greater detail in Section 4.6.1.

   On successful mutual authentication and ephemeral key agreement, the
   resource client and KMS communicate through the exchange of sequenced
   request and response messages encrypted using the ephemeral key.

4.2.  User Identity

   Central to the KMS server's role as a key store is its ability to
   both restrict access to stored keying material and to rekey keying
   material to only authorized users.  This requires robust user
   authentication and a means for the unambiguous and unique
   identification of each user.

   Conforming KMS architecture deployments MUST rely on an identity
   provider that supports the generation of OAuth 2.0 [RFC6749] access
   tokens.  The KMS server MUST rely on same identity provider for the
   purpose of validating access tokens received from the client.  Access
   tokens used by clients to demonstrate identity and authorization for
   access to KMS resources MUST NOT be used for any other service.  Any
   exposure of a KMS recognized access token to third parties (such as
   providers of other services or a resource server) jeopardizes the
   security of all GMBC and GK objectgs for which the user whose
   identity is represented by the token is authorized.

   The identity provider on which the KMS server relies MAY be the same
   identity provider as relied upon by the resource server(s) whose
   communications resources are encrypted with GK objects managed by the
   KMS server.  Note, however, the reliable authentication and
   authorization of clients to the KMS server is critical to the
   security of the KMS keys it holds.  The identity provider on which
   the KMS relies must therefore necessarily be regarded as a trusted
   party within the context of the KMS architecture.

   Access tokens MUST be conveyed to the KMS server as part of the
   payload of encrypted KMS API requests as described in Section 4.5.1
   and MUST NOT be conveyed in any other manner.

4.3.  KMS Identity

   Given the untrusted nature of the KMS transport by both the KMS and
   clients, it is critical for clients to be able to verify the identity
   of their KMS and ensure that no MITM attacks are carried out on
   client to KMS or KMS to client communications.  Therefore, the KMS
   MUST make use of at least one PKIX certificate [RFC5280] and clients



Biggs & Cooley           Expires January 4, 2016               [Page 17]

Internet-Draft           key-management-service                July 2015


   MUST validate the PKIX certificate presented by the KMS through the
   comparison of the certificate's common name (CN) or subject
   alternative name (SAN) [RFC6125] fields to the Internet domain
   portion of the user's Addr-spec [RFC2822] formatted unique identifier
   using the procedures defined in section 6 of [RFC6125].  An
   acceptable alternative to direct CN or SAN validation is defined in
   [I-D.ietf-xmpp-posh].

   PKIX certificates presented by the KMS can be issued by either a
   public or private certification authority with the stipulation that
   clients MUST be able to validate the KMS's entire certificate path
   through the pre-established trust of the root certificate used to
   anchor the certificate path.  The mechanism for establishing trust of
   the root certificate is out of scope for this specification, but it
   is usually carried out through pre-installed trusted root
   certificates on various operating systems for public certification
   authorities or through enterprise endpoint management solutions or
   manual installation tasks for private certification authorities.

4.4.  Object Types

   The KMS protocol is based on operations on GMBC and GK objects.
   Specifically, these include the following JSON object types defined
   using using JSON content rules [I-D.newton-json-content-rules] in
   [I-D.abiggs-saag-primitives-for-conf-group-comms]:

      gmbc-genesis-block

      gmbc-appended-block

      group-key

   It is through the creation and retrieval of instances of these object
   types that clients interact with the KMS.

4.5.  Message Structure

   Every KMS request and response message is composed of a JSON
   [RFC7159] formatted payload encapsulated within either a JWE
   [I-D.ietf-jose-json-web-encryption] or JWS
   [I-D.ietf-jose-json-web-signature] object.  These messages may be
   divided into three types.

   Common Messages

      Common messages include all those which do not meet the definition
      of either key agreement message or error message.  Common messages
      are encrypted as JWE objects using the shared ephemeral key



Biggs & Cooley           Expires January 4, 2016               [Page 18]

Internet-Draft           key-management-service                July 2015


      established during initial key agreement between the client and
      KMS (see Section 4.6.1).  The value of the JWE header "kid"
      attribute of a common message MUST match that of the KMS ephemeral
      key object URI attribute established during initial key agreement.

   Ephemeral Key Agreement Messages

      Ephemeral key agreement messages are those exchanged between the
      client and KMS for the purpose of establishing a new shared
      ephemeral key (see Section 4.6.1).  Key agreement request payloads
      are encrypted as JWE objects using the authenticated and validated
      static public key of the KMS.  Key agreement response payloads are
      signed as JWS objects using the static private key of the KMS.
      The value of the JWE or JWS header "kid" attribute of an ephemeral
      key agreement message MUST be a well known key identifier for the
      KMS static public key.

   Error Messages

      Error messages are those originated by the KMS to indicate a
      failed request.  Error messages are composed in the same fashion
      as common messages; however, in the event that the KMS does not
      recognize the ephemeral key used in the request, or that key is
      determined to have expired, the KMS MUST respond with an
      unencrypted message composed as a JWS, with a payload as described
      in Section 4.5.3, and signed using the KMS server's static public
      key.

   The basic JSON representations for the request and response payloads
   are defined in the following sections.

4.5.1.  Basic Request Payload

   The basic JSON representation for KMS request message payloads is
   defined as follows using JSON content rules
   [I-D.newton-json-content-rules] with references to rules defined in
   previous sections.














Biggs & Cooley           Expires January 4, 2016               [Page 19]

Internet-Draft           key-management-service                July 2015


   requestId (
     "requestId" : integer
   )

   credential {
     "userId": ?string
     "bearer": string / "jwk": jwk
   }

   client {
     "clientId": string,
     "credential": credential
   )

   method: string /create|retrieve|update|delete/

   request (
     "client" : client,
     "method" : method,
     "uri" : uri,
     requestId
   )

   The attributes of a KMS request message payload are defined as
   follows.

   requestId

      A string selected by the client and provided in each request to
      uniquely identify the request.  The string is treated opaquely by
      the server and returned verbatim in the associated response.

   userId

      The unique identifier of the user making the request.  This field
      is optional, and MUST be disregarded if the requesting user's
      identity can be securely derived from either the bearer token or
      jwk.

   bearer

      An [RFC6749] access token issued by the client's identity provider
      and validated by the KMS in cooperation with the identity
      provider.  See Section 4.2.

   jwk





Biggs & Cooley           Expires January 4, 2016               [Page 20]

Internet-Draft           key-management-service                July 2015


      A JWK object, in JSON format as defined in
      [I-D.ietf-jose-json-web-key], containing the public key of the
      client (presumably a server).  This JWK MUST contain an x5c header
      with a certificate chain that may be used to positively validate
      the public key.

   clientId

      An opaque unique identifier provided by the client (not used for
      authentication, only to assist multiple clients of a single user
      in differentiating between their respective unbound keys).

   method

      Indicates the request type: create, retrieve, update, or delete.

   uri

      A URI identifying a KMS object or object type (e.g.  GMBC or GK)
      to which the request applies.

   The JSON content rules above are used in conjunction with additional
   request type specific rules, defined later in this document, to
   produce the full request payload definition for each KMS operation.

4.5.2.  Basic Response Payload

   The basic JSON representation for KMS request message payloads is
   defined as follows using JSON content rules with references to rules
   defined in previous sections.

   response (
     "status" : integer,
     ?"reason" : string,
     requestId
   )

   The attributes of a KMS request message payload are defined as
   follows.

   status

      Indicates the success or failure of the request.  The value
      returned in a response status attribute SHOULD be that of an
      [RFC7231] defined status code with semantics that correspond to
      the success or failure condition of the KMS request.

   reason



Biggs & Cooley           Expires January 4, 2016               [Page 21]

Internet-Draft           key-management-service                July 2015


      An optional natural language string to describe the response
      status in terms that are useful for tracing and troubleshooting
      the API.

   requestId

      An echo of the requestId provided in the request.

   The JSON content rules above are used in conjunction with additional
   response type specific rules, defined later in this document, to
   produce the full response payload definition for each KMS operation.

4.5.3.  Error Response Payload

   The JSON representation for KMS error response message payloads is
   defined as follows using JSON content rules with references to rules
   defined in previous sections.

   Error response payload definition:

   root {
     response
   }

   Error response message example:

   JWS(K_kms_priv, {
     "status": 403,
     "reason": "The ephemeral key used in the request has expired.",
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5"
   })

4.6.  Requests

   The following sections provide detailed descriptions for each of the
   request and response operations that may occur between a resource
   client and the KMS.

4.6.1.  Create Ephemeral Key

   The first operation between a client and KMS MUST be the
   establishment of a shared secret and derived ephemeral key.  This is
   necessary as all other requests and responses are encrypted with the
   ephemeral key.

   The client request for creating an ephemeral key conforms to the
   basic request message payload, where the method is "create" and the
   uri is "/ecdhe".  In addition to the basic payload, the client



Biggs & Cooley           Expires January 4, 2016               [Page 22]

Internet-Draft           key-management-service                July 2015


   provides a jwk attribute for which the value is a JWK object
   [I-D.ietf-jose-json-web-key] containing the public part of an EC key
   pair generated by the client.  Unlike a basic request message,
   however, the request payload is encrypted as the content of a JWE
   [I-D.ietf-jose-json-web-key] secured with the static public key of
   the KMS server (K_kms_pub) as obtained from the server's validated
   PKIX certificate [RFC5280].

   Note, the client MUST generate a new EC key pair for every create
   ephemeral key request sent to the KMS server.

   Request payload definition:

   root {
     request,
     jwk
   }

   Request message example:

   JWE(K_kms_pub, {
     "client": {
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "credential": {
         "bearer": "ZWU5NGE2YWYtMGE2NC0..."
       }
     },
     "method": "create",
     "uri": "/ecdhe",
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
     "jwk" : {
       "kty": "EC",
       "crv": "P-256",
       "x": "VoFkf6Wk5kDQ1ob6csBmiMPHU8jALwdtaap35Fsj20M",
       "y": "XymwN6u2PmsKbIPy5iij6qZ-mIyej5dvZWB_75lnRgQ"
     }
   })

   On receiving the ephemeral key creation request, the KMS server MUST
   verify the credential provided in the request.  If a bearer token is
   provided, the KMS MUST validate the token in cooperation with the
   identity provider.  If a jwk is provided, the KMS MUST validate the
   included PKIX certificate chain against the KMS server's trust root.
   In either case, the identity of the requesting client MUST be
   authenticated and verified to correspond to either an authorized user
   of the KMS or an authorized trusted service.  If verification fails,
   the KMS MUST NOT use the server response to continue with key
   agreement.



Biggs & Cooley           Expires January 4, 2016               [Page 23]

Internet-Draft           key-management-service                July 2015


   Upon successful authentication and authorization of the request, the
   KMS responds by generating its own EC key pair using the same curve
   as indicated in the "crv" attribute of the request message JWK.  The
   KMS server returns the public part of this key pair to the resource
   client in the form of an EK object within the response payload.  The
   KMS also generates and includes within the response payload a new key
   uri to be regarded by both client and KMS as the key identifier of
   the agreed upon ephemeral key.  The response payload is returned to
   the resource client as the content of a JWS
   [I-D.ietf-jose-json-web-signature] signed using the static private
   key of the KMS server (K_kms_priv).

   Response payload definition:

   root {
     response,
     key
   }

   Response message example:

   JWS(K_kms_priv, {
     "status": 201,
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
     "ephemeral-key": {
       "uri": "/ecdhe/ea9f3858-1240-4328-ae22-a15f6072306f",
       "jwk" : {
         "kty": "EC",
         "crv": "P-256",
         "x": "8mdasnEZac2LWxMwKExikKU5LLacLQlcOt7A6n1ZGUC",
         "y": "lxs7ln5LtZUE_GE7yzc6BZOwBxtOftdsr8HVh-14ksS"
       },
       "userId": "842e2d82-7e71-4040-8eb9-d977fe888807",
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "createDate": "2014-10-09T15:54:48Z",
       "expirationDate": "2014-10-09T16:54:48Z"
     }
   })

   If successful, the KMS response to a create ephemeral key request
   MUST have a status of 201.  In the case of a request failure, the KMS
   response status SHOULD be that of an [RFC7231] defined status code
   with semantics that correspond to the failure condition.  In
   addition, the ephemeral key SHOULD have the createDate assigned as
   the current time and an expirationDate assigned as the latest point
   in time before which the key may be used for encrypting messages
   (both in [RFC3339] date-time format).




Biggs & Cooley           Expires January 4, 2016               [Page 24]

Internet-Draft           key-management-service                July 2015


   On receiving the ephemeral key creation response, the resource client
   MUST verify the received JWS against the KMS server's validated
   static public key.  If verification fails, the client MUST NOT use
   the server response to continue with key agreement.

   To generate the shared secret, both resource client and KMS server
   use ECDH shared secret derivation with the private part of the local
   EC key pair and the public part of the remote EC key pair.  The
   shared secret is then provided as input to HKDF (with both extract
   and expand, and empty salt) [RFC5869] to generate the ephemeral key
   (K_ephemeral).

   The ephemeral key generated by this operation is used to encrypt all
   subsequent KMS requests and responses passed between the resource
   client and KMS.  When encrypting such a message, the sender MUST
   assign a value to the kid attribute of the header of the resulting
   JWE object, and this value MUST match the URL of the key as provided
   to the client in the KMS response message described above.  This
   provides the recipient with a means for identifying the key necessary
   to decrypt the message.

   The KMS SHOULD accept messages encrypted with the ephemeral key up to
   and until the key expiration date as provided in the response message
   described above.  On expiration of the ephemeral key, the KMS MUST
   reject all further requests submitted using this key, and a client
   wishing to submit further requests to the KMS MUST re-establish the
   secure channel by requesting the creation of a new ephemeral key.

4.6.2.  Delete Ephemeral Key

   In the event that a resource client's ephemeral key has become
   compromised, a client SHOULD submit a request to the KMS to delete
   the ephemeral key.

   The request message conforms to the basic request message structure,
   where the method is "delete", and the uri is that of the ephemeral
   key to be deleted.

   Request payload definition:

   root {
     request
   }

   Request message example:






Biggs & Cooley           Expires January 4, 2016               [Page 25]

Internet-Draft           key-management-service                July 2015


   JWE(K_ephemeral, {
     "client": {
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "credential": {
         "bearer": "ZWU5NGE2YWYtMGE2NC0..."
       }
     }
     "method": "delete",
     "uri": "/ecdhe/ea9f3858-1240-4328-ae22-a15f6072306f",
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5"
   })

   The response message conforms to the basic response message
   structure, and MUST NOT include a representation of the deleted
   ephemeral key.

   Response payload definition:

   root {
     response
   }

   Response message example:

   JWE(K_ephemeral, {
     "status": 204,
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5"
   })

   If successful, the KMS response to a delete ephemeral key request
   MUST have a status of 204.  In the case of a request failure, the KMS
   response status SHOULD be that of an [RFC7231] defined status code
   with semantics that correspond to the failure condition.

   On successful deletion of an ephemeral key, the KMS MUST NOT, from
   that time forward, accept any requests encrypted with that ephemeral
   key.

4.6.3.  Post GMBC Genesis Block

   When a client intends to initiate E2E encryption of a communications
   resource, it begins by requesting the creation of a GMBC genesis
   block.  In this request, the client provides basic GMBC block
   information which the KMS uses in generating the genesis block.  The
   KMS will assign a unique GMBC URI to the genesis block and indicate
   itself as the GMBC curator.





Biggs & Cooley           Expires January 4, 2016               [Page 26]

Internet-Draft           key-management-service                July 2015


   The request message conforms to the basic request message structure,
   where the method is "post", and the path of the URI is "/blocks".

   Request payload definition:

   root {
       request,
       "blockPayload": gmbc-block
   }

   Request message example:

   JWE(K_ephemeral, {
     "client": {
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "credential": {
         "bearer": "ZWU5NGE2YWYtMGE2NC0..."
       }
     }
     "method": "post",
     "uri": "kms://kms.example.com/blocks",
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
     "blockPayload": {
         "creator": "bob@example.com",
         "created": "2015-11-02T19:02:15Z",
         "operations": [
             {
                 "entity": "bob@example.com",
                 "optype": "add"
             },
             {
                 "entity": "alice@example.com",
                 "optype": "add"
             }
         ]
     }
   })

   The response message conforms to the basic response message
   structure, and includes a representation of the created GMBC genesis
   block in the form of a compact-serialized JWS signed with the KMS
   server's private static key.

   Response payload definition:







Biggs & Cooley           Expires January 4, 2016               [Page 27]

Internet-Draft           key-management-service                July 2015


   signed-gmbc-genesis-block: JWS(K_kms_priv, gmbc-genesis-block)

   root {
     response,
     "block": signed-gmbc-genesis-block
   }

   Response message example:

   JWE(K_ephemeral, {
     "status": 201,
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
     "block": "eyAiYWxnIjogIlBTMjU2IiB9.ewogICAgICAidXJpIjo..."
   }

   Deserialized payload of the block attribute:

   JWS(K_kms_priv, {
         "uri": "kms://kms.example.com/blocks/7f35c3eb",
         "nonce": "32088b07-1a19-466b-a779-ef8dc8c61be9",
         "curator": "kms://kms.example.com",
         "creator": "kms://kms.example.com",
         "created": "2015-11-02T19:02:15Z",
         "operations": [
             {
                 "entity": "bob@example.com",
                 "optype": "add"
             },
             {
                 "entity": "alice@example.com",
                 "optype": "add"
             }
         ]
     }
   })

   If successful, the KMS response to a create resource request MUST
   have a status of 201.  In the case of a request failure, the KMS
   response status SHOULD be that of an [RFC7231] defined status code
   with semantics that correspond to the failure condition.

4.6.4.  Post GMBC Block

   Once a GMBC genesis block has been created, any member may append new
   blocks in order to modify the group membership.  This is done by
   submitting a post GMBC block request to the KMS.  In this request,
   the client provides a signed gmbc-appended-block and the URI of the
   genesis block of the GMBC to which it is to be appended.



Biggs & Cooley           Expires January 4, 2016               [Page 28]

Internet-Draft           key-management-service                July 2015


   The client may submit one or more blocks to be appended, the order of
   which they appear in the request representing the order in which they
   should be appended.  The KMS will validate that the antecedent hash
   of the first block matches the hash of the last block of the current
   chain, and that the antecedent of each subsequent block matches the
   hash of the previous block.  The KMS will also validate that each
   block is signed by an entity that qualifies as a member of the chain.
   If any of these checks fails, the KMS will fail the request in its
   entirety.

   The request message conforms to the basic request message structure,
   where the method is "post", and the uri is that of the GMBC.

   Request payload definition:

   signed-gmbc-appended-block: JWS(K_user_priv, gmbc-appended-block)

   root {
       request,
       "blocks" [ *: signed-gmbc-appended-block ]
   }

   Request message example:

   JWE(K_ephemeral, {
     "client": {
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "credential": {
         "bearer": "ZWU5NGE2YWYtMGE2NC0..."
       }
     }
     "method": "post",
     "uri": "kms://kms.example.com/blocks/7f35c3eb",
     "requestId": "6205452b-c555-484f-8445-bb94c8044882",
     "blocks": [
          "eyAiYWxnIjogIlBTMjU2IiB9.ewogICAgICAiYW50ZWNlZGVud..."
     ]
   })

   Deserialized payload of the block attribute:











Biggs & Cooley           Expires January 4, 2016               [Page 29]

Internet-Draft           key-management-service                July 2015


   JWS(K_alice_priv, {
         "antecedent": "3a2371f8fb6bb0f96e65dc535010b4004afc...",
         "creator": "alice@example.com",
         "created": "2015-11-02T19:13:15Z",
         "operations": [
             {
                 "entity": "charlie@example.com",
                 "optype": "add"
             },
             {
                 "entity": "bob@example.com",
                 "optype": "remove"
             }
         ]
     }
   })

   The response message conforms to the basic response message
   structure.

   Response payload definition:

   root {
     response
   }

   Response message example:

   JWE(K_ephemeral, {
     "status": 200,
     "requestId": "6205452b-c555-484f-8445-bb94c8044882",
   })

   If successful, the KMS response to a create resource request MUST
   have a status of 200.  In the case of a request failure, the KMS
   response status SHOULD be that of an [RFC7231] defined status code
   with semantics that correspond to the failure condition.

4.6.5.  Get GMBC

   A client may retrieve GMBC blocks from the KMS using the get GMBC
   operation.  The KMS MAY validate that the requesting client
   represents an entity that is a current member of the GMBC.
   Alternatively, a KMS MAY validate that the requesting client
   represents an entity that has been a member of the GMBC at some point
   in time.





Biggs & Cooley           Expires January 4, 2016               [Page 30]

Internet-Draft           key-management-service                July 2015


   The request message conforms to the basic request message structure,
   where the method is "get" and the uri is that of the GMBC's genesis
   block.  The client may also optionally request that only recently
   appended blocks be returned, by providing in an "antecedent"
   attribute the hash of a GMBC block the client already has.  The KMS
   will return any and all blocks which were appended after the block
   indicated by this hash value.

   Request payload definition:

   root {
     request
     ?"antecedent": string
   }

   Request message example:

   JWE(K_ephemeral, {
     "client": {
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "credential": {
         "bearer": "ZWU5NGE2YWYtMGE2NC0..."
       }
     }
     "method": "get",
     "uri": "kms://kms.example.com/blocks/7f35c3eb",
     "requestId": "db1e4d2a-d483-4fe7-a802-ec5c0d32295f"
   })

   The response message conforms to the basic response message
   structure, and includes an array containing the JWS compact-
   serialization of GMBC blocks in chronological order.

   Response payload definition:

   signed-gmbc-block:
           signed-gmbc-genesis-block / signed-gmbc-appended-block

   root {
     response,
     "blocks" [ *: signed-gmbc-block ]
   }

   Response message example:







Biggs & Cooley           Expires January 4, 2016               [Page 31]

Internet-Draft           key-management-service                July 2015


   JWE(K_ephemeral, {
     "status": 201,
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
     "blocks": [
       "eyAiYWxnIjogIlBTMjU2IiB9.ewogICAgICAidXJpIjogImttczovL...",
       "eyAiYWxnIjogIlBTMjU2IiB9.ewogICAgICAiYW50ZWNlZGVudCI6I..."
     ]
   })

   If successful, the KMS response to a retrieve resource request MUST
   have a status of 200.  In the case of a request failure, the KMS
   response status SHOULD be that of an [RFC7231] defined status code
   with semantics that correspond to the failure condition.

4.6.6.  Create GK

   When a client intends to initiate E2E encryption of a communications
   resource, it begins by requesting the creation of a GK URL.  This
   resource serves as a placeholder for the GK until the orignating
   client can post the contents of the GK.

   The request message conforms to the basic request message structure,
   where the method is "create", the uri is "/gk".

   Request message example:

   JWE(K_ephemeral, {
     "client": {
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "credential": {
         "bearer": "ZWU5NGE2YWYtMGE2NC0..."
       }
     }
     "method": "create",
     "uri": "/gk",
     "requestId": "8c198748-36fb-4318-89c9-bfc8bb0a967c",
   })

   The response message conforms to the basic response message
   structure, and includes a representation of the created GK.

   Response payload definition:

   root {
     response,
     resource-uris
   }




Biggs & Cooley           Expires January 4, 2016               [Page 32]

Internet-Draft           key-management-service                July 2015


   Response message example:

   JWE(K_ephemeral, {
     "status": 201,
     "requestId": "8c198748-36fb-4318-89c9-bfc8bb0a967c",
     "resource-uris": [
         "/gk/ee5f8984-2300-45af-872c-46aa874e0a8e",

     ]
   })

   If successful, the KMS response to a create resource request MUST
   have a status of 201.  In the case of a request failure, the KMS
   response status SHOULD be that of an [RFC7231] defined status code
   with semantics that correspond to the failure condition.

4.6.7.  Post GK

   Once a client has generated the GK, or when a client is modifying the
   GK, it must post the GK to the KMS.

   The request message conforms to the basic request message structure,
   where the method is "update", the uri is "/gk".

   Request message example:

   JWE(K_ephemeral, {
     "client": {
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "credential": {
         "bearer": "ZWU5NGE2YWYtMGE2NC0..."
       }
     }
     "method": "update",
     "uri": "/gk/ee5f8984-2300-45af-872c-46aa874e0a8e",
     "requestId": "e0f9b55c-d0a5-4f70-aafd-309541fe51ab",
     "resource": {
        TODO: GK example
     }
   })

   The response message conforms to the basic response message structure

   Response payload definition:

   root {
     response
   }



Biggs & Cooley           Expires January 4, 2016               [Page 33]

Internet-Draft           key-management-service                July 2015


   Response message example:

   JWE(K_ephemeral, {
     "status": 200,
     "requestId": "e0f9b55c-d0a5-4f70-aafd-309541fe51ab",
   })

   If successful, the KMS response to a create resource request MUST
   have a status of 200.  In the case of a request failure, the KMS
   response status SHOULD be that of an [RFC7231] defined status code
   with semantics that correspond to the failure condition.

4.6.8.  Retrieve GK

   A client that is authorized on a given GMBC may retrieve the current
   set of associated GK objects.

   The request message conforms to the basic request message structure,
   where the method is "retrieve", and the uri is that of the GK as
   returned by the create operation from which it originated.

   Request payload definition:

   root {
     request
   }

   Request message example:

   JWE(K_ephemeral, {
     "client": {
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "credential": {
         "bearer": "ZWU5NGE2YWYtMGE2NC0..."
       }
     }
     "method": "retrieve",
     "uri": "/GK/ee5f8984-2300-45af-872c-46aa874e0a8e",
     "requestId": "d83afbf1-523a-453a-8114-48c7df03ac7c",
   })

   The response message conforms to the basic response message
   structure, and includes a representation of the retrieved GK.

   Response payload definition:






Biggs & Cooley           Expires January 4, 2016               [Page 34]

Internet-Draft           key-management-service                July 2015


   root {
     response,
     resource
   }

   Response message example:

   JWE(K_ephemeral, {
     "status": 200,
     "requestId": "d83afbf1-523a-453a-8114-48c7df03ac7c",
     "resource": {
         TODO: GK example
     }
   })

   If successful, the KMS response to a retrieve resource request MUST
   have a status of 200.  In the case of a request failure, the KMS
   response status SHOULD be that of an [RFC7231] defined status code
   with semantics that correspond to the failure condition.

4.6.9.  Ping

   Ping is a simple request intended to provide an efficient means for
   verifying the integrity of the secure channel between client and KMS.
   Ping MUST be implemented as a safe and idempotent operation that
   causes the server to do nothing more than return a basic response
   payload in reaction to the client request.  The method of a ping
   request is "update" and the uri is "/ping".

   Request payload definition:

   root {
     request
   }

   Request message example:

   JWE(K_ephemeral, {
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5",
     "client": {
       "clientId": "android_a6aa012a-0795-4fb4-bddb-f04abda9e34f",
       "credential": {
         "bearer": "ZWU5NGE2YWYtMGE2NC0..."
       }
     }
     "method": "update",
     "uri": "/ping"
   })



Biggs & Cooley           Expires January 4, 2016               [Page 35]

Internet-Draft           key-management-service                July 2015


   The response message conforms to the basic response message structure
   with no additional data.

   Response payload definition:

   root {
     response
   }

   Response message example:

   JWE(K_ephemeral, {
   {
     "status": 200,
     "requestId": "10992782-e096-4fd3-9458-24dca7a92fa5"
   })

   If successful, the client may deduce that the KMS was able to
   successfully decrypt the received KMS request message, parse the
   contents, confirm the identity and authorization of the requesting
   client, and return a suitable response.

5.  Mandatory-to-Implement

   Implementations MUST support the following JWK key types from
   [I-D.ietf-jose-json-web-algorithms]:

   o  "RSA" for the KMS static public/private key

   o  "EC" for the Ephemeral Diffie Hellman exchange

   o  "oct" for all symmetric keys

   Implementations MUST support "PS256" (RSASSA-PSS using SHA-256 and
   MGF1 with SHA-256) from [I-D.ietf-jose-json-web-algorithms] for
   signatures using the KMS static public/private key for Section 4.6.1.

   Implementations MUST support JWK Elliptic Curve type "P-256" (NIST
   P-256 curve) from [I-D.ietf-jose-json-web-algorithms] for
   Section 4.6.1.

   Implementations MUST support "RSA-OAEP" (RSAES OAEP using default
   parameters) from [I-D.ietf-jose-json-web-algorithms] for key
   encryption using the KMS static public/private key for Section 4.6.1.

   Implementations MUST support "dir" (Direct Key Agreement Key
   Management Mode) from [I-D.ietf-jose-json-web-algorithms] for all
   operations other than Section 4.6.1.



Biggs & Cooley           Expires January 4, 2016               [Page 36]

Internet-Draft           key-management-service                July 2015


   Implementations MUST support "A256GCM" (AES GCM using 256 bit key)
   from [I-D.ietf-jose-json-web-algorithms] for content encryption for
   all operations other than Section 4.6.1.

6.  Security Considerations

   Security considerations are discussed throughout this document.
   Additional considerations may be added here as needed.

7.  Appendix A.  Acknowledgments

   This specification is the work of several contributors.  In
   particular, the following individuals contributed ideas, feedback,
   and wording that influenced this specification:

   Cullen Jennings, Matt Miller, Suhas Nandakumar, Jonathan Rosenberg

8.  Appendix B.  Document History

   -00

   o  Initial draft.

9.  References

9.1.  Normative References

   [I-D.abiggs-saag-primitives-for-conf-group-comms]
              Biggs, A. and S. Cooley, "Primitives for Confidential
              Group Communications", draft-abiggs-saag-primitives-for-
              conf-group-comms-00 (work in progress), September 2015.

   [I-D.ietf-jose-json-web-algorithms]
              Jones, M., "JSON Web Algorithms (JWA)", draft-ietf-jose-
              json-web-algorithms-33 (work in progress), September 2014.

   [I-D.ietf-jose-json-web-encryption]
              Jones, M. and J. Hildebrand, "JSON Web Encryption (JWE)",
              draft-ietf-jose-json-web-encryption-33 (work in progress),
              September 2014.

   [I-D.ietf-jose-json-web-key]
              Jones, M., "JSON Web Key (JWK)", draft-ietf-jose-json-web-
              key-33 (work in progress), September 2014.







Biggs & Cooley           Expires January 4, 2016               [Page 37]

Internet-Draft           key-management-service                July 2015


   [I-D.ietf-jose-json-web-signature]
              Jones, M., Bradley, J., and N. Sakimura, "JSON Web
              Signature (JWS)", draft-ietf-jose-json-web-signature-33
              (work in progress), September 2014.

   [RFC2119]  Bradner, S., "Key words for use in RFCs to Indicate
              Requirement Levels", BCP 14, RFC 2119, March 1997.

   [RFC2822]  Resnick, P., "Internet Message Format", RFC 2822, April
              2001.

   [RFC3339]  Klyne, G., Ed. and C. Newman, "Date and Time on the
              Internet: Timestamps", RFC 3339, July 2002.

   [RFC4949]  Shirey, R., "Internet Security Glossary, Version 2", RFC
              4949, August 2007.

   [RFC5280]  Cooper, D., Santesson, S., Farrell, S., Boeyen, S.,
              Housley, R., and W. Polk, "Internet X.509 Public Key
              Infrastructure Certificate and Certificate Revocation List
              (CRL) Profile", RFC 5280, May 2008.

   [RFC5869]  Krawczyk, H. and P. Eronen, "HMAC-based Extract-and-Expand
              Key Derivation Function (HKDF)", RFC 5869, May 2010.

   [RFC6125]  Saint-Andre, P. and J. Hodges, "Representation and
              Verification of Domain-Based Application Service Identity
              within Internet Public Key Infrastructure Using X.509
              (PKIX) Certificates in the Context of Transport Layer
              Security (TLS)", RFC 6125, March 2011.

   [RFC6749]  Hardt, D., "The OAuth 2.0 Authorization Framework", RFC
              6749, October 2012.

   [RFC7159]  Bray, T., "The JavaScript Object Notation (JSON) Data
              Interchange Format", RFC 7159, March 2014.

   [RFC7231]  Fielding, R. and J. Reschke, "Hypertext Transfer Protocol
              (HTTP/1.1): Semantics and Content", RFC 7231, June 2014.

9.2.  Informative References

   [I-D.barnes-pervasive-problem]
              Barnes, R., Schneier, B., Jennings, C., and T. Hardie,
              "Pervasive Attack: A Threat Model and Problem Statement",
              draft-barnes-pervasive-problem-01 (work in progress), July
              2014.




Biggs & Cooley           Expires January 4, 2016               [Page 38]

Internet-Draft           key-management-service                July 2015


   [I-D.ietf-xmpp-posh]
              Miller, M. and P. Saint-Andre, "PKIX over Secure HTTP
              (POSH)", draft-ietf-xmpp-posh-02 (work in progress),
              October 2014.

   [I-D.newton-json-content-rules]
              Newton, A., "A Language for Rules Describing JSON
              Content", draft-newton-json-content-rules-02 (work in
              progress), August 2014.

   [OTR]      Borisov, N., Goldberg, I., and E. Brewer, "Off-the-Record
              Communication, or, Why Not To Use PGP", 2012,
              <https://otr.cypherpunks.ca/otr-wpes.pdf>.

   [RFC4301]  Kent, S. and K. Seo, "Security Architecture for the
              Internet Protocol", RFC 4301, December 2005.

   [RFC4880]  Callas, J., Donnerhacke, L., Finney, H., Shaw, D., and R.
              Thayer, "OpenPGP Message Format", RFC 4880, November 2007.

   [RFC5246]  Dierks, T. and E. Rescorla, "The Transport Layer Security
              (TLS) Protocol Version 1.2", RFC 5246, August 2008.

   [RFC5652]  Housley, R., "Cryptographic Message Syntax (CMS)", STD 70,
              RFC 5652, September 2009.

Authors' Addresses

   Andrew Biggs
   Cisco Systems

   Email: adb@cisco.com


   Shaun Cooley
   Cisco Systems

   Email: shcooley@cisco.com













Biggs & Cooley           Expires January 4, 2016               [Page 39]
